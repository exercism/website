class TrainingData::CodeTagsSample::NormalizeTags
  include Mandate

  initialize_with :tags

  def call
    return nil if tags.nil?
    return nil if normalized_tags.empty?

    normalized_tags
  end

  def normalized_tags
    tags.flat_map { |tag| MAPPING.fetch(tag, tag) }.reject(&:blank?).uniq
  end

  MAPPING = {
    'concept:global-variable' => ['construct:global-variable'],
    'construct:addition-assignment' => ['construct:add-assignment'],
    'construct:algorithm' => [],
    'construct:and' => ['construct:logical-and'],
    'construct:annotation' => ['construct:attribute'],
    'construct:as-cast' => ['construct:type-conversion'],
    'construct:attributes' => ['construct:attribute'],
    'construct:auto' => ['construct:type-inference'],
    'construct:back_inserter' => [],
    'construct:back-tick' => [],
    'construct:backtick-escape' => [],
    'construct:bitset' => ['construct:bit-array'],
    'construct:boolean-logic' => ['technique:boolean-logic'],
    'construct:box' => ['construct:boxing'],
    'construct:by-convention' => [],
    'construct:c' => [],
    'construct:call' => ['construct:invocation'],
    'construct:calls' => ['construct:invocation'],
    'construct:case' => ['construct:switch'],
    'construct:char-literal' => ['construct:char'],
    'construct:checked-expression' => ['construct:checked-arithmetic'],
    'construct:checked' => ['construct:checked-arithmetic'],
    'construct:clear-host' => [],
    'construct:comparisons' => ['construct:comparison'],
    'construct:composition' => ['technique:composition'],
    'construct:const' => ['construct:constant'],
    'construct:constructor-initializer' => ['construct:object-initializer'],
    'construct:context-manager' => [],
    'construct:def' => ['construct:function'],
    'construct:default-argument' => ['construct:default'],
    'construct:define' => ['construct:macro'],
    'construct:definition' => [],
    'construct:dict' => ["construct:dictionary"],
    'construct:do-loop' => ["construct:do-while-loop"],
    'construct:do-until-loop' => ["construct:do-while-loop"],
    'construct:double-precision:floating-point-number' => ['construct:double'],
    'construct:echo' => ['construct:print'],
    'construct:either' => ['construct:result'],
    'construct:elif-statement' => ['construct:else'],
    'construct:elif' => ['construct:else'],
    'construct:else-statement' => ['construct:else'],
    'construct:elseif' => ['construct:else'],
    'construct:equality-comparison' => ['construct:equality'],
    'construct:equality-test' => ['construct:equality'],
    'construct:equals' => ['construct:equality'],
    'construct:error-handling' => ['technique:error-handling'],
    'construct:except' => [],
    'construct:exit' => [],
    'construct:expression' => [],
    'construct:foldl' => [],
    'construct:format' => ['construct:string-formatting'],
    'construct:from-import' => ['construct:explicit-import'],
    'construct:function-definition' => ['construct:function'],
    'construct:generator-expression' => ['construct:generator'],
    'construct:get-word' => [],
    'construct:global-variables' => ['construct:global-variable'],
    'construct:identity-comparison' => ['construct:equality'],
    'construct:identity-test' => ['construct:type-test'],
    'construct:if-else' => ['construct:if', 'construct:else'],
    'construct:if-statement' => ['construct:if', 'construct:else'],
    'construct:if-then-else' => ['construct:if', 'construct:else'],
    'construct:imaginary-number' => ['construct:complex-number'],
    'construct:impl' => ['construct:type-extension'],
    'construct:include' => ['construct:import'],
    'construct:index' => ['construct:indexing'],
    'construct:indexed-access' => ['construct:indexing'],
    'construct:infinite-iterator' => ["construct:iterator"],
    'construct:infix-operators' => ['construct:infix-operator'],
    'construct:inheritance' => ['technique:inheritance'],
    'construct:inline-docs' => ['construct:comment'],
    'construct:integer' => ['construct:int'],
    'construct:integral-type' => ['construct:integral-number'],
    'construct:is-cast' => ['construct:type-test'],
    'construct:iterable' => ['construct:iterator'],
    'construct:iteration' => ['technique:enumeration'],
    'construct:keep' => [],
    'construct:left-shift' => ['construct:bitwise-left-shift'],
    'construct:length' => [],
    'construct:let' => ['construct:variable'],
    'construct:library' => [],
    'construct:literal' => [],
    'construct:local' => [],
    'construct:logical-operator' => ['technique:boolean-logic'],
    'construct:long-double' => ['construct:double'],
    'construct:long-long-int' => ['construct:long'],
    'construct:long-long' => ['construct:long'],
    'construct:make' => [],
    'construct:map' => [],
    'construct:meta-table' => ['construct:metatable'],
    'construct:method-invocation' => ['construct:invocation'],
    'construct:modulus' => ['construct:modulo'],
    'construct:mul' => ['construct:multiply'],
    'construct:multiline-comment' => ['construct:comment'],
    'construct:named-arguments' => ['construct:named-argument'],
    'construct:named-parameter' => [],
    'construct:negation' => ['construct:logical-not'],
    'construct:nested-conditional' => ['construct:nesting'],
    'construct:nested-dict' => ['construct:dictionary', 'construct:nesting'],
    'construct:nested-if' => ['construct:if', 'construct:nesting'],
    'construct:nested-loop' => ['construct:loop', 'construct:nesting'],
    'construct:nested-tuple' => ['construct:tuple', 'construct:nesting'],
    'construct:nil' => ['construct:null'],
    'construct:none' => ['construct:null'],
    'construct:nullptr' => ['construct:null', 'construct:pointer'],
    'construct:object' => ['construct:instance'],
    'construct:optional-type' => ['construct:option'],
    'construct:or' => ['construct:logical-or'],
    'construct:overloading' => ['construct:function-overloading'],
    'construct:parameter-type' => ['construct:parameter'],
    'construct:parenthesized' => ['construct:parenthesized-expression'],
    'construct:path' => [],
    'construct:patterns' => ['construct:pattern'],
    'construct:position' => [],
    'construct:positional-arguments' => [],
    'construct:positional-parameter' => [],
    'construct:power' => ['construct:exponentiation'],
    'construct:pragma' => [],
    'construct:printf' => ['construct:print'],
    'construct:private-attribute' => [],
    'construct:python-None' => ['construct:null'],
    'construct:python-raw-string' => ['construct:verbatim-string'],
    'construct:raise' => ['construct:throw'],
    'construct:ranges' => ['construct:range'],
    'construct:read-host' => [],
    'construct:recursion' => ['technique:recursion'],
    'construct:reduce' => [],
    'construct:refinement' => [],
    'construct:rejoin' => [],
    'construct:remainder' => ['construct:modulo'],
    'construct:repeat' => ['construct:do-while-loop'],
    'construct:reverse' => [],
    'construct:right-shift' => ['construct:bitwise-right-shift'],
    'construct:set-difference' => [],
    'construct:setmetatable' => ['construct:metatable'],
    'construct:single-quoted-string' => ['construct:string'],
    'construct:sort' => ['technique:sorting'],
    'construct:sqrt' => [],
    'construct:static-method' => ["construct:static-method"],
    'construct:string-concatenation' => ['construct:concatenation', 'construct:string'],
    'construct:subtraction-assignment' => ['construct:subtract-assignment'],
    'construct:switch-expression' => ['construct:switch'],
    'construct:table-insertation' => [],
    'construct:table-insertion' => [],
    'construct:tail-call' => ["technique:tail-call-optimization", "technique:recursion"],
    'construct:take' => [],
    'construct:template-template-parameter' => ['construct:template-parameter'],
    'construct:ternary' => ['construct:conditional-operator'],
    'construct:then' => ['construct:else'],
    'construct:throw-expression' => ['construct:throw'],
    'construct:throwable' => ['construct:throw'],
    'construct:transform' => [],
    'construct:trinary' => [],
    'construct:true' => ['construct:boolean'],
    'construct:typedef' => ['construct:type-alias'],
    'construct:uint64_t' => ['construct:ulong'],
    'construct:underscore' => ['construct:discard'],
    'construct:unless' => ['construct:while-loop'],
    'construct:unordered-map' => ['construct:dictionary'],
    'construct:unpacking' => ['construct:destructuring'],
    'construct:unsigned-int' => ['construct:uint'],
    'construct:unsigned-integral' => ['construct:uint'],
    'construct:using-declaration' => ['construct:using-directive'],
    'construct:usize' => ['construct:nuint'],
    'construct:value-comparision' => ['construct:comparison'],
    'construct:value-comparison' => ['construct:comparison'],
    'construct:value-test' => ['construct:equality'],
    'construct:value' => [],
    'construct:verbatim' => ['construct:verbatim-string'],
    'construct:word' => ['construct:short'],
    'construct:write-host' => [],
    'construct:year' => [],
    'constuct:lambda' => ['construct:lambda'],
    'paradigm:higher-order-functions' => [],
    'paradigm:looping' => [],
    'paradigm:template-metaprogramming' => ["paradigm:meta"],
    'techinique:regular-expressions' => ['technique:regular-expression'],
    'technique: laziness' => ["technique:laziness"],
    'technique:async' => ['technique:concurrency'],
    'technique:closure' => [],
    'technique:copy-empty-series' => [],
    'technique:functional-composition' => ['technique:function-composition'],
    'technique:logic-function' => [],
    'technique:minimal-header' => [],
    'technique:multiprocessing' => [],
    'technique:performance' => [],
    'technique:regular-expressions' => ['technique:regular-expression'],
    'technique:search' => [],
    'technique:set-algebra' => [],
    'uses.math.cosin' => ['uses:math.cosin'],
    'uses.math.sin' => ['uses:math.sin']
  }.freeze
  private_constant :MAPPING
end
