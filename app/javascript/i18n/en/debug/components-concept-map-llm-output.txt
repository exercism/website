```ts
// i18n
export default {
  "exerciseStatusBar.exerciseStatusDotTooltip": "Exercise Status Dot Tooltip",
  "concept.availableConcept": "Available Concept:",
  "concept.learnedConcept": "Learned Concept:",
  "concept.masteredConcept": "Mastered Concept:",
  "concept.lockedConcept": "Locked Concept:",
  "concept.concept": "Concept:"
}

// modified_files
// === file: ../components/concept-map/ExerciseStatusBar.tsx ===
import * as React from 'react'
import { ExerciseStatusDot } from '../student'
import { ExerciseData } from './concept-map-types'

export const ExerciseStatusBar = ({
  exercisesData,
}: {
  exercisesData: ExerciseData[]
}): JSX.Element | null => {
  if (exercisesData.length === 0) {
    return null
  }

  return (
    <div className="exercise-status-bar hidden lg:flex">
      {exercisesData.map((data, i) => statusMapper(data, i))}
    </div>
  )
}

export const PureExerciseStatusBar = React.memo(ExerciseStatusBar)

const statusMapper = (data: ExerciseData, key: number): JSX.Element => {
  return (
    <ExerciseStatusDot
      key={key}
      exerciseStatus={data.status}
      type={data.type}
      links={{ tooltip: data.tooltipUrl, exercise: data.url }}
    />
  )
}

// === end file ===
// === file: ../components/concept-map/Concept.tsx ===
import React, { useEffect, useRef, useState, MouseEventHandler } from 'react'
import { ConceptTooltip } from '../tooltips'
import { useAppTranslation } from '@/i18n/useAppTranslation'

import { IConcept, ConceptStatus, ExerciseData } from './concept-map-types'

import { emitConceptElement } from './helpers/concept-element-svg-handler'
import {
  addVisibilityListener,
  removeVisibilityListener,
  Visibility,
} from './helpers/concept-visibility-handler'
import { wrapAnimationFrame } from './helpers/animation-helpers'
import { PureExerciseStatusBar } from './ExerciseStatusBar'
import { ConceptIcon } from '../common/ConceptIcon'
import { ExercismTippy } from '../misc/ExercismTippy'

type ConceptProps = IConcept & {
  handleEnter: MouseEventHandler
  handleLeave: MouseEventHandler
  status: ConceptStatus
  exercisesData: ExerciseData[]
  isActive: boolean
}

export const Concept = ({
  slug,
  name,
  webUrl,
  tooltipUrl,
  handleEnter,
  handleLeave,
  status,
  exercisesData,
  isActive,
}: ConceptProps): JSX.Element => {
  const { t } = useAppTranslation('components/concept-map')
  const isLocked = status === 'locked'
  // sets the initial visibility, to avoid the flash of unstyled content
  const [visibility, setVisibility] = useState<Visibility>('hidden')

  // reference to the concept anchor tag
  const conceptRef = useRef(null)

  useEffect(() => {
    const current = conceptRef.current
    emitConceptElement(slug, current)
    addVisibilityListener(setVisibility)
    return () => {
      emitConceptElement(slug)
      removeVisibilityListener(setVisibility)
    }
  }, [slug, conceptRef])

  // Build the class list
  const classes: string[] = ['card']
  classes.push(status)
  if (isActive) {
    classes.push('active')
  }
  if (visibility === 'hidden') {
    classes.push('hidden')
  }

  return (
    <div role="presentation">
      <div
        ref={conceptRef}
        id={conceptSlugToId(slug)}
        className={classes.join(' ')}
        data-concept-slug={slug}
        data-concept-status={status}
      >
        <ExercismTippy
          content={<ConceptTooltip endpoint={tooltipUrl} />}
          duration={[null, 0]}
          interactive
        >
          <a
            className="display"
            href={webUrl}
            onMouseEnter={wrapAnimationFrame(handleEnter)}
            onMouseLeave={wrapAnimationFrame(handleLeave)}
          >
            <ConceptIcon name={name} size="medium" />
            <span className="name" aria-label={getAriaLabel(status, t)}>
              {name}
            </span>
          </a>
        </ExercismTippy>
        {!isLocked && <PureExerciseStatusBar exercisesData={exercisesData} />}
      </div>
    </div>
  )
}

export const PureConcept = React.memo(Concept)

export function conceptSlugToId(slug: string): string {
  return `concept-${slug}`
}

const getAriaLabel = (status: ConceptStatus, t: any): string => {
  switch (status) {
    case 'available':
      return t('concept.availableConcept')
    case 'learned':
      return t('concept.learnedConcept')
    case 'mastered':
      return t('concept.masteredConcept')
    case 'locked':
      return t('concept.lockedConcept')
    default:
      return t('concept.concept')
  }
}

// === end file ===
// === file: ../components/concept-map/ConnectionPathSVG.tsx ===
import React, { useEffect, useReducer } from 'react'
import { useWebpageSize } from './hooks/useWebpageSize'

import { PurePathLineSVG } from './PathLineSVG'
import { PurePathLineEndSVG } from './PathLineEndSVG'

import { ConceptConnection, ConceptPathProperties } from './concept-map-types'

import {
  addElementDispatcher,
  removeElementDispatcher,
  ElementReducer,
} from './helpers/concept-element-svg-handler'

import { computePathProperties } from './helpers/path-helpers'

import { camelize } from 'humps'

const elementReducer: ElementReducer = (_, nextElements) => nextElements

export const ConnectionPathSVG = ({
  activeConcepts,
  connection,
}: {
  activeConcepts: Set<string>
  connection: ConceptConnection
}): JSX.Element | null => {
  const from = camelize(connection.from)
  const to = camelize(connection.to)
  const webpageSize = useWebpageSize()
  const [{ startElementRef, endElementRef }, dispatchRef] = useReducer(
    elementReducer,
    {
      startElementRef: null,
      endElementRef: null,
    }
  )

  useEffect(() => {
    addElementDispatcher(dispatchRef, from, to)
    return () => {
      removeElementDispatcher(dispatchRef, from, to)
    }
  }, [from, to, dispatchRef, webpageSize])

  const pathProperties: ConceptPathProperties | null =
    startElementRef !== null && endElementRef !== null
      ? computePathProperties(startElementRef, endElementRef)
      : null

  if (pathProperties === null) return null

  const {
    status,
    height,
    width,
    radius,
    pathStart,
    pathEnd,
    translateX,
    translateY,
    pathCourse,
  } = pathProperties

  // Compute ClassNames
  const existsActivePaths = activeConcepts.size > 0
  const isActive =
    !existsActivePaths || (activeConcepts.has(from) && activeConcepts.has(to))

  const classNames = ['connection', status]
  if (isActive) {
    classNames.push('active')
  }

  return (
    <svg
      viewBox={`0 0 ${width} ${height}`}
      style={{
        width: `${width}px`,
        height: `${height}px`,
        transform: `translate(${translateX}px, ${translateY}px)`,
      }}
      className={classNames.join(' ')}
      data-from={from}
      data-to={to}
      data-testid={`path-${connection.from}-${connection.to}`}
    >
      <g>
        <PurePathLineSVG
          pathStart={pathStart}
          pathEnd={pathEnd}
          course={pathCourse}
        />
        <PurePathLineEndSVG cx={pathStart.x} cy={pathStart.y} radius={radius} />
        <PurePathLineEndSVG cx={pathEnd.x} cy={pathEnd.y} radius={radius} />
      </g>
    </svg>
  )
}

// === end file ===
// === file: ../components/concept-map/PathLineEndSVG.tsx ===
import React from 'react'

export const PathLineEndSVG = ({
  cx,
  cy,
  radius,
}: {
  cx: number
  cy: number
  radius: number
}): JSX.Element => {
  return <circle cx={cx} cy={cy} r={radius} />
}

export const PurePathLineEndSVG = React.memo(PathLineEndSVG)

// === end file ===
// === file: ../components/concept-map/PathLineSVG.tsx ===
import React from 'react'

import { PathCourse, ConceptPathCoordinate } from './concept-map-types'

export const PathLineSVG = ({
  pathStart,
  pathEnd,
  course,
}: {
  pathStart: ConceptPathCoordinate
  pathEnd: ConceptPathCoordinate
  course: PathCourse
}): JSX.Element => {
  const computedBezier: string = React.useMemo(
    () => computeCurve(pathStart, pathEnd, course),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [pathStart.x, pathStart.y, pathEnd.x, pathEnd.y, course]
  )

  return <path d={computedBezier} />
}

export const PurePathLineSVG = React.memo(PathLineSVG)

function computeCurve(
  start: ConceptPathCoordinate,
  end: ConceptPathCoordinate,
  course: PathCourse
): string {
  switch (course) {
    case 'left':
      return drawLeft(start, end)
    case 'right':
      return drawRight(start, end)
    case 'center-left':
      return drawCenterLeft(start, end)
    case 'center-right':
      return drawCenterRight(start, end)
  }
  return drawTopDown(start, end)
}

function drawTopDown(start: ConceptPathCoordinate, end: ConceptPathCoordinate) {
  const halfDeltaY = (end.y - start.y) / 2
  const dx1 = start.x
  const dy1 = start.y + halfDeltaY
  const dx2 = end.x
  const dy2 = end.y - halfDeltaY

  return `M ${start.x}, ${start.y} C ${dx1}, ${dy1} ${dx2}, ${dy2} ${end.x}, ${end.y}`
}

function drawLeft(start: ConceptPathCoordinate, end: ConceptPathCoordinate) {
  const deltaX = start.x - end.x
  const deltaY = end.y - start.y
  const dx1 = start.x - deltaX * 0.5
  const dy1 = start.y
  const dx2 = end.x
  const dy2 = end.y - deltaY * 0.5

  return `M ${start.x}, ${start.y} C ${dx1}, ${dy1} ${dx2}, ${dy2} ${end.x}, ${end.y}`
}

function drawRight(start: ConceptPathCoordinate, end: ConceptPathCoordinate) {
  const deltaX = end.x - start.x
  const deltaY = end.y - start.y
  const dx1 = start.x + deltaX * 0.5
  const dy1 = start.y
  const dx2 = end.x
  const dy2 = end.y - deltaY * 0.5

  return `M ${start.x}, ${start.y} C ${dx1}, ${dy1} ${dx2}, ${dy2} ${end.x}, ${end.y}`
}

function drawCenterRight(
  start: ConceptPathCoordinate,
  end: ConceptPathCoordinate
) {
  const deltaX = Math.abs(start.x - end.x)
  const halfDeltaY = (end.y - start.y) / 2
  const dx1 = start.x + deltaX * 0.5
  const dy1 = start.y
  const dx2 = end.x
  const dy2 = end.y - halfDeltaY

  return `M ${start.x}, ${start.y} C ${dx1}, ${dy1} ${dx2}, ${dy2} ${end.x}, ${end.y}`
}

function drawCenterLeft(
  start: ConceptPathCoordinate,
  end: ConceptPathCoordinate
) {
  const deltaX = Math.abs(start.x - end.x)
  const halfDeltaY = (end.y - start.y) / 2
  const dx1 = start.x - deltaX * 0.5
  const dy1 = start.y
  const dx2 = end.x
  const dy2 = end.y - halfDeltaY

  return `M ${start.x}, ${start.y} C ${dx1}, ${dy1} ${dx2}, ${dy2} ${end.x}, ${end.y}`
}

// === end file ===
// === file: ../components/concept-map/ConceptMap.tsx ===
import React, { useCallback, useMemo, useState } from 'react'
import { useAppTranslation } from '@/i18n/useAppTranslation'

import { PureConcept } from './Concept'
import { ConceptConnections } from './ConceptConnections'

import {
  IConceptMap,
  IConcept,
  isIConcept,
  ConceptConnection,
} from './concept-map-types'
import { useFontLoaded } from './hooks/useFontLoaded'
import { camelize } from 'humps'

type AdjacentIndex = Map<string, Set<string>>
type RelationReducer = (connection: ConceptConnection) => [string, string]

interface IndexAdjacentBySlug {
  (
    connections: ConceptConnection[],
    relationReducer: RelationReducer,
    index?: AdjacentIndex
  ): AdjacentIndex
}

export default function ConceptMap({
  concepts,
  levels,
  connections,
  status,
  exercisesData,
}: IConceptMap): JSX.Element {
  const { t } = useAppTranslation('components/concept-map')
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const fontLoaded = useFontLoaded('Poppins')
  const [activeSlug, setActiveSlug] = useState<string | null>(null)
  const unsetActiveSlug = useCallback(
    () => setActiveSlug(null),
    [setActiveSlug]
  )

  const conceptsBySlug = useMemo(
    () => indexConceptsBySlug(concepts),
    [concepts]
  )
  const descendantsBySlug = useMemo(
    () => indexDescendantsBySlug(connections),
    [connections]
  )
  const parentsBySlug = useMemo(
    () => indexParentsBySlug(connections),
    [connections]
  )
  const activeSlugsBySlug = useMemo(
    () => indexActiveSlugsBySlug(concepts, parentsBySlug, descendantsBySlug),
    [concepts, parentsBySlug, descendantsBySlug]
  )
  const activeSlugs = activeSlug
    ? activeSlugsBySlug.get(activeSlug) ?? new Set<string>()
    : new Set<string>()

  return (
    <>
      <figure className="c-concepts-map">
        <div className="track">
          {levels.map((layer, i: number) => (
            <div key={`layer-${i}`} className="layer">
              {layer
                .map((conceptSlug) => conceptsBySlug.get(camelize(conceptSlug)))
                .filter(isIConcept)
                .map((concept) => {
                  const slug = camelize(concept.slug)
                  const isActive = activeSlug === null || activeSlugs.has(slug)

                  return (
                    <PureConcept
                      key={slug}
                      slug={slug}
                      name={concept.name}
                      webUrl={concept.webUrl}
                      tooltipUrl={concept.tooltipUrl}
                      exercisesData={exercisesData[slug]}
                      handleEnter={() => setActiveSlug(slug)}
                      handleLeave={unsetActiveSlug}
                      status={status[slug] ?? 'unavailable'}
                      isActive={isActive}
                    />
                  )
                })}
            </div>
          ))}
        </div>
        <ConceptConnections
          connections={connections}
          activeConcepts={activeSlugs}
        />
      </figure>
    </>
  )
}

function indexConceptsBySlug(concepts: IConcept[]): Map<string, IConcept> {
  return concepts.reduce((memo, concept) => {
    memo.set(camelize(concept.slug), concept)
    return memo
  }, new Map<string, IConcept>())
}

const indexAdjacentBySlug: IndexAdjacentBySlug = function (
  connections,
  relationReducer,
  index = new Map()
): AdjacentIndex {
  const addToIndex = (index: AdjacentIndex, from: string, to: string): void => {
    const adjacent = index.get(from) ?? new Set()
    adjacent.add(to)
    index.set(from, adjacent)
  }

  return connections.reduce((relatives, connection) => {
    const [from, to] = relationReducer(connection)
    addToIndex(relatives, from, to)
    return relatives
  }, index)
}

const indexParentsBySlug = function (
  connections: ConceptConnection[]
): AdjacentIndex {
  const parentReducer: RelationReducer = (connection) => [
    camelize(connection.to),
    camelize(connection.from),
  ]
  return indexAdjacentBySlug(connections, parentReducer)
}

const indexDescendantsBySlug = function (
  connections: ConceptConnection[]
): AdjacentIndex {
  const descendantReducer: RelationReducer = (connection) => [
    camelize(connection.from),
    camelize(connection.to),
  ]
  return indexAdjacentBySlug(connections, descendantReducer)
}

const findAllActiveSlugs = function (
  parentsBySlug: AdjacentIndex,
  descendantsBySlug: AdjacentIndex,
  activeSlug: string | null
): Set<string> {
  if (activeSlug === null) {
    return new Set()
  }

  const activeSlugs = new Set([activeSlug])
  const processedSlugs = new Set<string>()
  const queue = [activeSlug]

  while (queue.length > 0) {
    const slug = queue.pop() as string
    if (processedSlugs.has(slug)) {
      continue
    }
    activeSlugs.add(slug)
    const parentSlugs = slug ? Array.from(parentsBySlug.get(slug) ?? []) : []
    queue.push(...parentSlugs)
  }

  const descendantSlugs = descendantsBySlug.get(activeSlug) ?? new Set<string>()
  descendantSlugs.forEach((descendantSlug) => activeSlugs.add(descendantSlug))

  return activeSlugs
}

const indexActiveSlugsBySlug = function (
  concepts: IConcept[],
  parentsBySlug: AdjacentIndex,
  descendantsBySlug: AdjacentIndex
): Map<string, Set<string>> {
  const index = new Map<string, Set<string>>()

  concepts.forEach((concept) => {
    const slug = camelize(concept.slug)
    const activeSlugsWhenConceptActive = findAllActiveSlugs(
      parentsBySlug,
      descendantsBySlug,
      slug
    )
    index.set(slug, activeSlugsWhenConceptActive)
  })

  return index
}

// === end file ===
// === file: ../components/concept-map/ConceptConnections.tsx ===
import React from 'react'

import { ConceptConnection } from './concept-map-types'
import { ConnectionPathSVG } from './ConnectionPathSVG'

export const ConceptConnections = ({
  connections,
  activeConcepts,
}: {
  connections: ConceptConnection[]
  activeConcepts: Set<string>
}): JSX.Element => {
  return (
    <>
      {connections.map((connection) => {
        const key = connectionToKey(connection)
        return (
          <ConnectionPathSVG
            key={key}
            activeConcepts={activeConcepts}
            connection={connection}
          />
        )
      })}
    </>
  )
}

function connectionToKey({ from, to }: ConceptConnection): string {
  return `path-${from}-${to}`
}

// === end file ===
```