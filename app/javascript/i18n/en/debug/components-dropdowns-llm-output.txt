```ts
// i18n
export default {
  "useDropdown.arrowDown": "ArrowDown",
  "useDropdown.arrowUp": "ArrowUp",
  "useDropdown.tab": "Tab",
  "useDropdown.escape": "Escape",
  "trackMenu.seeTrackOnGithub": "See {{trackTitle}} track on Github <graphicalIcon0/>",
  "trackMenu.documentation": "{{trackTitle}} documentation",
  "trackMenu.trackBuildStatus": "Track Build Status",
  "trackMenu.disableLearningMode": "Disable Learning Modeâ€¦",
  "trackMenu.enableLearningMode": "Enable Learning Modeâ€¦",
  "trackMenu.resetTrack": "Reset trackâ€¦",
  "trackMenu.leaveTrack": "Leave trackâ€¦",
  "notifications.seeAllYourNotifications": "See all your notifications<graphicalIcon0/>",
  "notifications.unableToLoad": "Unable to load notifications",
  "reputation.unableToRetrieve": "Unable to retrieve reputation tokens"
}

// modified_files
// === file: ../components/dropdowns/useDropdown.tsx ===
import React, {
  useState,
  useEffect,
  useMemo,
  useRef,
  KeyboardEvent,
} from 'react'
import { usePanel } from '../../hooks/use-panel'
import { v4 as uuidv4 } from 'uuid'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type DropdownAttributes = {
  buttonAttributes: ButtonAttributes
  panelAttributes: any
  itemAttributes: (index: number) => ItemAttributes
  listAttributes: ListAttributes
  open: boolean
  setOpen: (open: false) => void
}

type ButtonAttributes = {
  'aria-controls': string
  'aria-haspopup': true
  'aria-expanded': boolean | undefined
  ref: (element: HTMLButtonElement) => void
  onKeyDown: (e: KeyboardEvent) => void
  onClick: () => void
}

type ItemAttributes = {
  ref: (instance: HTMLLIElement) => void
  onKeyDown: (e: KeyboardEvent) => void
  tabIndex: -1
  role: 'menuitem'
}

type ListAttributes = {
  id: string
  role: 'menu'
  hidden: boolean
}

export const useDropdown = (
  itemLength: number,
  onItemSelect?: (index: number) => void,
  panelOptions?: any
): DropdownAttributes => {
  const { t } = useAppTranslation('components/dropdowns')
  const {
    open,
    setOpen,
    buttonElement,
    buttonAttributes,
    panelAttributes,
  } = usePanel(panelOptions || {})
  const menuItemElementsRef = useRef<HTMLLIElement[]>([])
  const [focusIndex, setFocusIndex] = useState<number | null | undefined>()
  const id = useMemo(() => {
    return uuidv4()
  }, [])

  const handleButtonKeyDown = (e: React.KeyboardEvent) => {
    switch (e.key) {
      case t('useDropdown.arrowDown'):
        e.preventDefault()
        setOpen(true)
        setFocusIndex(0)

        break
      case t('useDropdown.arrowUp'):
        e.preventDefault()
        setOpen(true)
        setFocusIndex(itemLength - 1)

        break
    }
  }

  const handleItemKeyDown = (e: React.KeyboardEvent, index: number) => {
    switch (e.key) {
      case t('useDropdown.arrowDown'):
        e.preventDefault()
        setFocusIndex((index + itemLength + 1) % itemLength)

        break
      case t('useDropdown.arrowUp'):
        e.preventDefault()
        setFocusIndex((index + itemLength - 1) % itemLength)

        break
      case t('useDropdown.tab'):
        setOpen(false)

        break
      case t('useDropdown.escape'):
        e.preventDefault()
        setOpen(false)
        setFocusIndex(null)

        break
      case ' ':
      case 'Enter': {
        e.preventDefault()

        if (onItemSelect) {
          onItemSelect(index)
        } else {
          const link = menuItemElementsRef.current[index].querySelector('a')
          const button = menuItemElementsRef.current[index].querySelector(
            'button'
          )

          setOpen(false)
          link?.click()
          button?.click()
        }

        break
      }
    }
  }

  const handleMenuItemMount = (
    instance: HTMLLIElement | null,
    index: number
  ) => {
    if (!instance) {
      return
    }

    menuItemElementsRef.current[index] = instance
  }

  useEffect(() => {
    if (focusIndex === undefined) {
      return
    }

    if (focusIndex === null) {
      buttonElement?.focus()

      return
    }

    menuItemElementsRef.current[focusIndex].focus()
  }, [open, focusIndex, buttonElement])

  return {
    buttonAttributes: {
      'aria-controls': id,
      'aria-haspopup': true,
      'aria-expanded': open ? true : undefined,
      ...buttonAttributes,
      onClick: () => setOpen(!open),
      onKeyDown: handleButtonKeyDown,
    },
    panelAttributes: panelAttributes,
    listAttributes: {
      id: id,
      role: 'menu',
      hidden: !open,
    },
    itemAttributes: (i: number) => {
      return {
        ref: (instance: HTMLLIElement) => handleMenuItemMount(instance, i),
        onKeyDown: (e: KeyboardEvent) => handleItemKeyDown(e, i),
        tabIndex: -1,
        role: 'menuitem',
      }
    },
    open,
    setOpen,
  }
}

// === end file ===

// === file: ../components/dropdowns/TrackMenu.tsx ===
import React, { useState } from 'react'
import { useDropdown } from './useDropdown'
import { Track } from '../types'
import { Icon, GraphicalIcon } from '../common'
import { ActivatePracticeModeModal } from './track-menu/ActivatePracticeModeModal'
import { ActivateLearningModeModal } from './track-menu/ActivateLearningModeModal'
import { ResetTrackModal } from './track-menu/ResetTrackModal'
import { LeaveTrackModal } from './track-menu/LeaveTrackModal'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type Links = {
  repo: string
  documentation: string
  activatePracticeMode?: string
  activateLearningMode?: string
  reset?: string
  leave?: string
}

type ModalType = 'learning' | 'practice' | 'reset' | 'leave'

export default function TrackMenu({
  track,
  links,
  ariaHideApp = false,
}: {
  track: Track
  links: Links
  ariaHideApp?: boolean
}): JSX.Element {
  const { t } = useAppTranslation('components/dropdowns')
  const [modal, setModal] = useState<ModalType | null>(null)
  const {
    buttonAttributes,
    panelAttributes,
    listAttributes,
    itemAttributes,
    open,
  } = useDropdown(5, undefined, {
    placement: 'bottom-start',
    modifiers: [
      {
        name: 'offset',
        options: {
          offset: [0, 8],
        },
      },
    ],
  })

  return (
    <div className="c-track-menu">
      <button {...buttonAttributes}>
        <Icon icon="more-horizontal" alt="Track options" />
      </button>
      {open ? (
        <div {...panelAttributes} className="c-dropdown-generic-menu">
          <ul {...listAttributes}>
            <li {...itemAttributes(0)}>
              <a href={links.repo} target="_blank" rel="noreferrer">
                <GraphicalIcon icon="external-site-github" />
                {t('trackMenu.seeTrackOnGithub', {
                  trackTitle: track.title,
                  graphicalIcon0: <GraphicalIcon icon="external-link" className="external-link" />
                })}
              </a>
            </li>
            <li {...itemAttributes(1)}>
              <a href={links.documentation} target="_blank" rel="noreferrer">
                <GraphicalIcon icon="docs" />
                {t('trackMenu.documentation', { trackTitle: track.title })}
              </a>
            </li>
            <li {...itemAttributes(2)}>
              <a href={links.buildStatus}>
                <GraphicalIcon icon="building" />
                {t('trackMenu.trackBuildStatus')}
              </a>
            </li>
            {links.activatePracticeMode ? (
              <li {...itemAttributes(2)}>
                <button type="button" onClick={() => setModal('practice')}>
                  <GraphicalIcon icon="practice-mode" />
                  {t('trackMenu.disableLearningMode')}
                </button>
              </li>
            ) : links.activateLearningMode ? (
              <li {...itemAttributes(2)}>
                <button type="button" onClick={() => setModal('learning')}>
                  <GraphicalIcon icon="concepts" />
                  {t('trackMenu.enableLearningMode')}
                </button>
              </li>
            ) : null}
            {links.reset ? (
              <li {...itemAttributes(3)}>
                <button type="button" onClick={() => setModal('reset')}>
                  <GraphicalIcon icon="reset" />
                  {t('trackMenu.resetTrack')}
                </button>
              </li>
            ) : null}
            {links.leave ? (
              <li {...itemAttributes(4)}>
                <button type="button" onClick={() => setModal('leave')}>
                  <div className="emoji">ðŸ‘‹</div>
                  {t('trackMenu.leaveTrack')}
                </button>
              </li>
            ) : null}
          </ul>
        </div>
      ) : null}
      {links.activatePracticeMode ? (
        <ActivatePracticeModeModal
          open={modal === 'practice'}
          onClose={() => setModal(null)}
          endpoint={links.activatePracticeMode}
          ariaHideApp={ariaHideApp}
        />
      ) : null}
      {links.activateLearningMode ? (
        <ActivateLearningModeModal
          open={modal === 'learning'}
          onClose={() => setModal(null)}
          endpoint={links.activateLearningMode}
          ariaHideApp={ariaHideApp}
        />
      ) : null}
      {links.reset ? (
        <ResetTrackModal
          open={modal === 'reset'}
          track={track}
          onClose={() => setModal(null)}
          endpoint={links.reset}
          ariaHideApp={ariaHideApp}
        />
      ) : null}
      {links.leave ? (
        <LeaveTrackModal
          open={modal === 'leave'}
          track={track}
          onClose={() => setModal(null)}
          endpoint={links.leave}
          ariaHideApp={ariaHideApp}
        />
      ) : null}
    </div>
  )
}

// === end file ===

// === file: ../components/dropdowns/Notifications.tsx ===
import React, { useEffect, useState } from 'react'
import consumer from '../../utils/action-cable-consumer'
import { GraphicalIcon } from '../common/GraphicalIcon'
import { NotificationsIcon } from './notifications/NotificationsIcon'
import { Notification } from '../notifications/notifications-list/Notification'
import { Notification as NotificationType } from '../types'
import { useNotificationDropdown } from './notifications/useNotificationDropdown'
import { DropdownAttributes } from './useDropdown'
import { usePaginatedRequestQuery } from '../../hooks/request-query'
import { useErrorHandler, ErrorBoundary } from '../ErrorBoundary'
import { Loading } from '../common/Loading'
import { QueryStatus } from '@tanstack/react-query'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type APIResponse = {
  results: NotificationType[]
  meta: {
    total: number
    unreadCount: number
    links: {
      all: string
    }
  }
}

const DEFAULT_ERROR = new Error('Unable to load notifications')

const ErrorMessage = ({ error }: { error: unknown }) => {
  useErrorHandler(error, { defaultError: DEFAULT_ERROR })

  return null
}

const ErrorFallback = ({ error }: { error: Error }) => {
  return <p>{error.message}</p>
}

const DropdownContent = ({
  data,
  status,
  error,
  listAttributes,
  itemAttributes,
}: {
  data: APIResponse | undefined
  status: QueryStatus
  error: unknown
} & Pick<DropdownAttributes, 'listAttributes' | 'itemAttributes'>) => {
  const { t } = useAppTranslation('components/dropdowns')
  if (data) {
    return (
      <ul {...listAttributes}>
        {data.results.map((notification, i) => {
          return (
            <li {...itemAttributes(i)} key={i}>
              <Notification {...notification} />
            </li>
          )
        })}
        <li {...itemAttributes(data.results.length)}>
          <a href={data.meta.links.all} className="c-prominent-link">
            <span>{t('notifications.seeAllYourNotifications', { graphicalIcon0: <GraphicalIcon icon="arrow-right" /> })}</span>
          </a>
        </li>
      </ul>
    )
  } else {
    const { id, hidden } = listAttributes

    return (
      <div id={id} hidden={hidden}>
        {status === 'pending' ? <Loading /> : null}
        <ErrorBoundary FallbackComponent={ErrorFallback}>
          <ErrorMessage error={error} />
        </ErrorBoundary>
      </div>
    )
  }
}

const MAX_NOTIFICATIONS = 5
export const NOTIFICATIONS_CACHE_KEY = 'notifications'

export default function Notifications({
  endpoint,
}: {
  endpoint: string
}): JSX.Element {
  const { t } = useAppTranslation('components/dropdowns')
  const [isStale, setIsStale] = useState(false)
  const {
    data: resolvedData,
    error,
    status,
    refetch,
  } = usePaginatedRequestQuery<APIResponse, unknown>(
    [NOTIFICATIONS_CACHE_KEY],
    {
      endpoint: endpoint,
      query: { per_page: MAX_NOTIFICATIONS },
      options: {
        staleTime: 1000 * 60 * 5,
        refetchOnMount: true,
      },
    }
  )
  const {
    buttonAttributes,
    panelAttributes,
    listAttributes,
    itemAttributes,
    open,
  } = useNotificationDropdown(resolvedData)

  useEffect(() => {
    const subscription = consumer.subscriptions.create(
      { channel: 'NotificationsChannel' },
      {
        received: () => {
          setIsStale(true)
        },
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  useEffect(() => {
    if (!listAttributes.hidden || !isStale) {
      return
    }

    refetch()
    setIsStale(false)
  }, [isStale, listAttributes.hidden, refetch])

  return (
    <React.Fragment>
      <NotificationsIcon
        count={resolvedData?.meta?.unreadCount || 0}
        aria-label="Open notifications"
        {...buttonAttributes}
      />
      {open ? (
        <div className="c-notifications-dropdown" {...panelAttributes}>
          <DropdownContent
            data={resolvedData}
            status={status}
            error={error}
            itemAttributes={itemAttributes}
            listAttributes={listAttributes}
          />
        </div>
      ) : null}
    </React.Fragment>
  )
}

// === end file ===

// === file: ../components/dropdowns/Dropdown.tsx ===
import React from 'react'
import { useDropdown } from './useDropdown'
import { useAppTranslation } from '@/i18n/useAppTranslation'

type MenuButton = {
  label: string
  className: string
  extraClassNames?: string[]
  html: string
}

type MenuItem = {
  html: string
  className: string
}

export default function Dropdown({
  menuButton,
  menuItems,
}: {
  menuButton: MenuButton
  menuItems: MenuItem[]
}): JSX.Element {
  const { t } = useAppTranslation('components/dropdowns')
  const {
    buttonAttributes,
    panelAttributes,
    listAttributes,
    itemAttributes,
    open,
  } = useDropdown(menuItems.length, undefined, {
    placement: 'bottom-start',
    modifiers: [
      {
        name: 'offset',
        options: {
          offset: [0, 8],
        },
      },
    ],
  })

  return (
    <React.Fragment>
      <button
        className={`${menuButton.className} ${
          menuButton.extraClassNames ? menuButton.extraClassNames.join(' ') : ''
        }`}
        dangerouslySetInnerHTML={{ __html: menuButton.html }}
        aria-label={menuButton.label}
        {...buttonAttributes}
      />
      {open ? (
        <div {...panelAttributes}>
          <ul
            className={`${menuButton.className}-dropdown`}
            {...listAttributes}
          >
            {menuItems.map((item, i) => {
              return (
                <li
                  key={i}
                  dangerouslySetInnerHTML={{ __html: item.html }}
                  className={item.className}
                  {...itemAttributes(i)}
                />
              )
            })}
          </ul>
        </div>
      ) : null}
    </React.Fragment>
  )
}

// === end file ===

// === file: ../components/dropdowns/Reputation.tsx ===
import React, { useEffect, useState } from 'react'
import { ReputationIcon } from './reputation/ReputationIcon'
import { ReputationMenu } from './reputation/ReputationMenu'
import { ReputationChannel } from '../../channels/reputationChannel'
import { useDropdown, DropdownAttributes } from './useDropdown'
import { QueryKey, QueryStatus, useQueryClient } from '@tanstack/react-query'
import { useErrorHandler, ErrorBoundary } from '../ErrorBoundary'
import { Loading } from '../common/Loading'
import { usePaginatedRequestQuery } from '../../hooks/request-query'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type Links = {
  tokens: string
}

export type ReputationToken = {
  uuid: string
  internalUrl?: string
  externalUrl?: string
  iconUrl: string
  text: string
  createdAt: string
  value: string
  isSeen: boolean
  links: {
    markAsSeen: string
  }
}

export type APIResponse = {
  results: ReputationToken[]
  meta: {
    links: {
      tokens: string
    }
    totalReputation: number
    unseenTotal: number
  }
}

const DEFAULT_ERROR = new Error('Unable to retrieve reputation tokens')

const ErrorMessage = ({ error }: { error: unknown }) => {
  useErrorHandler(error, { defaultError: DEFAULT_ERROR })

  return null
}

const ErrorFallback = ({ error }: { error: Error }) => {
  return <p>{error.message}</p>
}

const DropdownContent = ({
  data,
  cacheKey,
  status,
  error,
  listAttributes,
  itemAttributes,
}: {
  data: APIResponse | undefined
  cacheKey: QueryKey
  status: QueryStatus
  error: unknown
} & Pick<DropdownAttributes, 'listAttributes' | 'itemAttributes'>) => {
  const { t } = useAppTranslation('components/dropdowns')
  if (data) {
    return (
      <ReputationMenu
        tokens={data.results}
        links={data.meta.links}
        listAttributes={listAttributes}
        itemAttributes={itemAttributes}
        cacheKey={cacheKey}
      />
    )
  } else {
    const { id, hidden } = listAttributes

    return (
      <div id={id} hidden={hidden}>
        {status === 'pending' ? <Loading /> : null}
        <ErrorBoundary FallbackComponent={ErrorFallback}>
          <ErrorMessage error={error} />
        </ErrorBoundary>
      </div>
    )
  }
}

const MAX_TOKENS = 5
export const REPUTATION_CACHE_KEY = 'reputations'

export default function Reputation({
  defaultReputation,
  defaultIsSeen,
  endpoint,
}: {
  defaultReputation: number
  defaultIsSeen: boolean
  endpoint: string
}): JSX.Element {
  const { t } = useAppTranslation('components/dropdowns')
  const [isStale, setIsStale] = useState(false)
  const [reputation, setReputation] = useState(defaultReputation)
  const [isSeen, setIsSeen] = useState(defaultIsSeen)

  const {
    data: resolvedData,
    error,
    status,
    refetch,
  } = usePaginatedRequestQuery<APIResponse>([REPUTATION_CACHE_KEY], {
    endpoint: endpoint,
    query: { per_page: MAX_TOKENS },
    options: {
      staleTime: 1000 * 60 * 5,
      refetchOnMount: true,
    },
  })

  const {
    buttonAttributes,
    panelAttributes,
    listAttributes,
    itemAttributes,
    open,
  } = useDropdown((resolvedData?.results.length || 0) + 1, undefined, {
    placement: 'bottom-start',
    modifiers: [
      {
        name: 'offset',
        options: {
          offset: [0, 8],
        },
      },
    ],
  })

  useEffect(() => {
    const connection = new ReputationChannel(() => setIsStale(true))

    return () => connection.disconnect()
  }, [])

  useEffect(() => {
    if (!resolvedData) {
      return
    }

    setReputation(resolvedData.meta.totalReputation)
  }, [resolvedData])

  useEffect(() => {
    if (!resolvedData) {
      return
    }

    setIsSeen(resolvedData.meta.unseenTotal === 0)
  }, [resolvedData])

  useEffect(() => {
    if (!listAttributes.hidden || !isStale) {
      return
    }

    refetch()
    setIsStale(false)
  }, [isStale, listAttributes.hidden, refetch])

  return (
    <React.Fragment>
      <ReputationIcon
        reputation={reputation}
        isSeen={isSeen}
        {...buttonAttributes}
      />
      {open ? (
        <div className="c-reputation-dropdown" {...panelAttributes}>
          <DropdownContent
            data={resolvedData}
            cacheKey={[REPUTATION_CACHE_KEY]}
            status={status}
            error={error}
            itemAttributes={itemAttributes}
            listAttributes={listAttributes}
          />
        </div>
      ) : null}
    </React.Fragment>
  )
}

// === end file ===
```