```ts
// i18n
export default {
  "testRunSummary.noTestResults": "No test results",
  "testRunSummary.trackNotSupportTests": "This track does not support automatically running exercise tests.",
  "testRunSummary.exerciseNotSupportTests": "This exercise does not support automatically running its tests.",
  "testRunSummary.testingCode": "We're testing your code to check it works",
  "testRunSummary.usuallyTakes": "This usually takes {{averageTestDuration}}-{{averageTestDurationMultiplied}} seconds.",
  "testRunSummary.tasksCompleted": "{{completedTasks}} / {{totalTasks}} Tasks Completed",
  "testRunSummary.allTasksPassed": "All tasks passed",
  "testRunSummary.allTestsPassed": "All tests passed",
  "testRunSummary.anErrorOccurred": "An error occurred",
  "testRunSummary.yourTestsTimedOut": "Your tests timed out",
  "testRunSummary.sweetLooksLike": "Sweet. Looks like you've solved the exercise!",
  "testRunSummary.goodJobContinueImprove": "Good job! You can continue to improve your code or, if you're done, submit an iteration to get automated feedback and optionally request mentoring.",
  "testRunSummary.weReceivedError": "We received the following error when we ran your code:",
  "testRunSummary.errorOccurredWhileRunningTests": "An error occurred while running your tests. This might mean that there was an issue in our infrastructure, or it might mean that you have something in your code that's causing our systems to break.",
  "testRunSummary.pleaseCheckCode": "Please check your code, and if nothing seems to be wrong, try running the tests again.",
  "testRunSummary.yourTestsTimedOutSuggestsCodeRunningSlowly": "Your tests timed out. This might mean that there was an issue in our infrastructure, but more likely it suggests that your code is running slowly. Is there an infinite loop or something similar?",
  "testRunSummary.runningTests": "Running testsâ€¦",
  "testRunSummary.estimatedRunningTime": "Estimated running time ~ {{averageTestDuration}}s",
  "testRunSummary.cancel": "Cancel",
  "testRunOutput.v1Message": "",
  "testPanel.hidden": "",
  "testsGroupedByStatusList.test": "{{count}} test",
  "testsGroupedByStatusList.tests": "{{count}} tests",
  "testsGroupedByStatusList.passed": "passed",
  "testsGroupedByStatusList.failed": "failed",
  "testRunSummaryByStatusHeaderMessage.testFailure": "test failure",
  "testRunSummaryByStatusHeaderMessage.testFailures": "test failures",
  "testRunSummaryByStatusHeaderMessage.testsFailed": "Tests failed",
  "testsGroupedByTaskList.task": "Task",
  "testsGroupedByTaskList.jumpToInstructions": "Jump to Instructions",
  "testSummary.passed": "Passed",
  "testSummary.failed": "Failed",
  "testSummary.test": "Test",
  "testSummary.codeRun": "Code Run",
  "testSummary.testFailure": "Test Failure",
  "testSummary.testError": "Test Error",
  "testSummary.yourOutput": "Your Output",
  "testContentWrapper.fileNotFound": "File not found"
}

// modified_files
// === file: ../components/editor/testComponents/TestRunSummary.tsx ===
// i18n-key-prefix: testRunSummary
// i18n-namespace: components/editor/testComponents
import React from 'react'
import { TestRun, TestRunner, TestRunStatus, TestStatus } from '../types'
import { TestRunSummaryByStatusHeaderMessage } from './TestRunSummaryByStatusHeaderMessage'
import { TestRunOutput } from './TestRunOutput'
import { SubmitButton } from '../SubmitButton'
import { GraphicalIcon } from '../../common'
import { LoadingBar } from '../../common/LoadingBar'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export const TestRunSummary = ({
  testRun,
  testRunner,
  onSubmit,
  isSubmitDisabled,
  onCancel,
  showSuccessBox,
}: {
  testRun: TestRun
  testRunner: TestRunner
  onSubmit?: () => void
  isSubmitDisabled?: boolean
  onCancel?: () to void
  showSuccessBox: boolean
}): JSX.Element => {
  const { t } = useAppTranslation('components/editor/testComponents')

  if (testRun) {
    return (
      <div className="c-test-run">
        <TestRunSummaryHeader testRun={testRun} />
        <TestRunSummaryContent
          testRun={testRun}
          testRunner={testRunner}
          onSubmit={onSubmit}
          isSubmitDisabled={isSubmitDisabled}
          onCancel={onCancel}
          showSuccessBox={showSuccessBox}
        />
      </div>
    )
  }

  if (testRunner.status && !testRunner.status.track) {
    return (
      <div className="test-runner-disabled">
        <h3>{t('testRunSummary.noTestResults')}</h3>
        <p>{t('testRunSummary.trackNotSupportTests')}</p>
      </div>
    )
  }

  if (testRunner.status && !testRunner.status.exercise) {
    return (
      <div className="test-runner-disabled">
        <h3>{t('testRunSummary.noTestResults')}</h3>
        <p>{t('testRunSummary.exerciseNotSupportTests')}</p>
      </div>
    )
  }

  return (
    <div className="automated-feedback-pending">
      <GraphicalIcon icon="spinner" className="animate-spin-slow" />
      <h3>{t('testRunSummary.testingCode')}</h3>
      <p>
        {t('testRunSummary.usuallyTakes', {
          averageTestDuration: testRunner.averageTestDuration,
          averageTestDurationMultiplied: testRunner.averageTestDuration * 4,
        })}
      </p>
    </div>
  )
}

const TestRunSummaryStatus = ({
  statusClass,
  children,
  percentagePassing,
}: React.PropsWithChildren<{
  statusClass: string
  percentagePassing: number
}>): JSX.Element => {
  return (
    <>
      <div className={`progress ${statusClass}`}>
        <div className="bar" style={{ width: `${percentagePassing}%` }} />
      </div>
      <div className={`summary-status ${statusClass}`} role="status">
        <span className="--dot" />
        {children}
      </div>
    </>
  )
}

const TestRunSummaryHeader = ({ testRun }: { testRun: TestRun }) => {
  const { t } = useAppTranslation('components/editor/testComponents')

  const hasTasks =
    testRun.version >= 3 &&
    testRun.tasks.length > 0 &&
    testRun.tests.every((t) => t.taskId !== null && t.taskId !== undefined)

  switch (testRun.status) {
    case TestRunStatus.FAIL: {
      const failed = testRun.tests.filter(
        (test) =>
          test.status === TestStatus.FAIL || test.status === TestStatus.ERROR
      )

      if (hasTasks) {
        const numFailedTasks = new Set(
          failed
            .filter((test) => test.taskId !== undefined)
            .map((test) => test.taskId)
        ).size

        return (
          <TestRunSummaryStatus
            statusClass="failed grouped-by-task"
            percentagePassing={
              ((testRun.tests.length - failed.length) / testRun.tests.length) *
              100
            }
          >
            {t('testRunSummary.tasksCompleted', {
              completedTasks: testRun.tasks.length - numFailedTasks,
              totalTasks: testRun.tasks.length,
            })}
          </TestRunSummaryStatus>
        )
      }

      return (
        <TestRunSummaryStatus
          statusClass="failed"
          percentagePassing={
            ((testRun.tests.length - failed.length) / testRun.tests.length) *
            100
          }
        >
          <TestRunSummaryByStatusHeaderMessage
            version={testRun.version}
            numFailedTests={failed.length}
          />
        </TestRunSummaryStatus>
      )
    }
    case TestRunStatus.PASS:
      if (hasTasks) {
        return (
          <TestRunSummaryStatus statusClass="passed" percentagePassing={100}>
            {t('testRunSummary.allTasksPassed')}
          </TestRunSummaryStatus>
        )
      }

      return (
        <TestRunSummaryStatus statusClass="passed" percentagePassing={100}>
          {t('testRunSummary.allTestsPassed')}
        </TestRunSummaryStatus>
      )
    case TestRunStatus.ERROR:
    case TestRunStatus.OPS_ERROR:
      return (
        <TestRunSummaryStatus statusClass="errored" percentagePassing={100}>
          {t('testRunSummary.anErrorOccurred')}
        </TestRunSummaryStatus>
      )
    case TestRunStatus.TIMEOUT:
      return (
        <TestRunSummaryStatus statusClass="errored" percentagePassing={100}>
          {t('testRunSummary.yourTestsTimedOut')}
        </TestRunSummaryStatus>
      )
    default:
      return null
  }
}

const TestRunSummaryContent = ({
  testRun,
  testRunner,
  onSubmit,
  isSubmitDisabled,
  onCancel,
  showSuccessBox,
}: {
  testRun: TestRun
  testRunner: TestRunner
  onSubmit?: () => void
  isSubmitDisabled?: boolean
  onCancel?: () => void
  showSuccessBox: boolean
}) => {
  const { t } = useAppTranslation('components/editor/testComponents')

  switch (testRun.status) {
    case TestRunStatus.PASS: {
      return (
        <>
          {showSuccessBox ? (
            <div className="success-box">
              <GraphicalIcon icon="balloons" category="graphics" />
              <div className="content">
                <h3>{t('testRunSummary.sweetLooksLike')}</h3>
                <p>
                  {t('testRunSummary.goodJobContinueImprove')}
                </p>
                {onSubmit !== undefined && isSubmitDisabled !== undefined ? (
                  <SubmitButton
                    onClick={onSubmit}
                    disabled={isSubmitDisabled}
                  />
                ) : null}
              </div>
            </div>
          ) : null}
          {testRun.version === 2 || testRun.version === 3 ? (
            <TestRunOutput testRun={testRun} />
          ) : null}
        </>
      )
    }
    case TestRunStatus.FAIL:
      return <TestRunOutput testRun={testRun} />
    case TestRunStatus.ERROR:
      return (
        <div className="error-message">
          <h3>{t('testRunSummary.weReceivedError')}</h3>
          <pre>
            <code dangerouslySetInnerHTML={{ __html: testRun.messageHtml }} />
          </pre>
        </div>
      )
    case TestRunStatus.OPS_ERROR:
      return (
        <div className="ops-error">
          <p>
            {t('testRunSummary.errorOccurredWhileRunningTests')}
          </p>
          <p>
            {t('testRunSummary.pleaseCheckCode')}
          </p>
        </div>
      )
    case TestRunStatus.TIMEOUT:
      return (
        <div className="ops-error">
          <p>
            {t('testRunSummary.yourTestsTimedOutSuggestsCodeRunningSlowly')}
          </p>
          <p>
            {t('testRunSummary.pleaseCheckCode')}
          </p>
        </div>
      )
    case TestRunStatus.QUEUED: {
      return (
        <div role="status" className="running">
          <GraphicalIcon icon="spinner" className="animate-spin-slow" />
          <LoadingBar animationDuration={testRunner.averageTestDuration} />
          <p>
            <strong>{t('testRunSummary.runningTests')}</strong>&nbsp;
            <span>
              {t('testRunSummary.estimatedRunningTime', {
                averageTestDuration: testRunner.averageTestDuration,
              })}
            </span>
          </p>
          {onCancel !== undefined &&
          testRun.submissionUuid !== 'faux-submission' ? (
            <button
              type="button"
              onClick={() => onCancel()}
              className="btn-default btn-xs"
            >
              {t('testRunSummary.cancel')}
            </button>
          ) : null}
        </div>
      )
    }
    default:
      return null
  }
}

// === end file ===

// === file: ../components/editor/testComponents/TestRunOutput.tsx ===
// i18n-key-prefix: testRunOutput
// i18n-namespace: components/editor/testComponents
import React from 'react'
import { TestRun } from '../types'
import { TestsGroupedByStatusList } from './TestsGroupedByStatusList'
import { TestsGroupedByTaskList } from './TestsGroupedByTaskList'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export const TestRunOutput = ({
  testRun,
}: {
  testRun: TestRun
}): JSX.Element => {
  const { t } = useAppTranslation('components/editor/testComponents')

  const hasTasks =
    testRun.version >= 3 &&
    testRun.tasks.length > 0 &&
    testRun.tests.every((t) => t.taskId !== null && t.taskId !== undefined)

  if (hasTasks) {
    return (
      <TestsGroupedByTaskList
        tests={testRun.tests}
        language={testRun.highlightjsLanguage}
        tasks={testRun.tasks}
      />
    )
  }

  if (testRun.version >= 2 && testRun.tests.length > 0) {
    return (
      <TestsGroupedByStatusList
        tests={testRun.tests}
        language={testRun.highlightjsLanguage}
      />
    )
  }

  return (
    <pre className="v1-message">
      <code dangerouslySetInnerHTML={{ __html: testRun.messageHtml }} />
    </pre>
  )
}

// === end file ===

// === file: ../components/editor/testComponents/TestPanel.tsx ===
// i18n-key-prefix: testPanel
// i18n-namespace: components/editor/testComponents
import React, { useContext, useLayoutEffect, useRef, useState } from 'react'
import { highlightAll } from '@/utils/highlight'
import { Tab } from '@/components/common/Tab'
import { TestContentContext, TestTabContext } from './TestContentWrapper'
import { useAppTranslation } from '@/i18n/useAppTranslation'

type TestPanelProps = {
  highlightjsLanguage: string
}
export const TestPanel = ({
  highlightjsLanguage,
}: TestPanelProps): JSX.Element => {
  const { t } = useAppTranslation('components/editor/testComponents')

  const { testTab } = useContext(TestContentContext)

  const testRef = useRef<HTMLPreElement>(null)
  const memoTestRef = useRef<HTMLDivElement>(null)

  const [treeMap, setTreeMap] = useState<{ [key: string]: HTMLPreElement }>({})
  const [reusing, setReusing] = useState<boolean>(false)

  // useLayoutEffect is necessary, because the highlighting must be completed _before_ render
  useLayoutEffect(() => {
    if (!testRef.current || !memoTestRef.current) {
      return
    }

    // The highlighter fn is a bit expensive to run, therefore this block makes sure it won't be run on the same file again
    // see https://github.com/exercism/website/pull/3320
    // Checks if the filename has already been transformed into a highlighted representation
    // if not, highlights it, and saves it in a hashMap
    if (!(testTab.filename in treeMap)) {
      setReusing(false)
      highlightAll(testRef.current)

      // disable linter - if we get here, testRef.current is guaranteed to be here, otherwise it would've returned early
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setTreeMap((t) => ({ ...t, [testTab.filename]: testRef.current! }))
    } else {
      setReusing(true)

      // when testTab is updated, it removes the previously rendered dom element -  which comes from the treeMap hashmap
      while (memoTestRef.current.firstChild) {
        memoTestRef.current.removeChild(memoTestRef.current.firstChild)
      }

      // ...and appends another child element to our memoTestRef container
      memoTestRef.current.appendChild(treeMap[testTab.filename])
    }

    // we only want to rerun it if testTab changes
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [testTab])

  return (
    <Tab.Panel
      id={testTab.filename}
      context={TestTabContext}
      className="tests c-code-pane"
    >
      {/*
        this cannot be removed from the DOM, because if this pre tag doesn't exist,
        a new testFile is loaded for the first time (not from the hashmap), the highlighter useEffect won't run,
        because testRef.current will be missing, will exit early, won't render anything.

        this can be further optimized by comparing filenames and keys stored in the hashmap
        and ejecting this block if the two numbers/arrays are the same
        but is not necessary at this point
        */}
      <pre
        ref={testRef}
        className={reusing ? 'hidden' : ''}
        key={testTab.filename}
      >
        <code
          className={highlightjsLanguage}
          data-highlight-line-numbers={true}
          data-highlight-line-number-start={1}
        >
          {testTab.content}
        </code>
      </pre>
      {/* injecting cached DOM elements into this container */}
      <div className={reusing ? '' : 'hidden'} ref={memoTestRef}></div>
    </Tab.Panel>
  )
}

// === end file ===

// === file: ../components/editor/testComponents/TestList.tsx ===
// i18n-key-prefix: testList
// i18n-namespace: components/editor/testComponents
import React from 'react'
import { Test } from '../types'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export function TestsList({ tests }: { tests: Test[] }) {
  const { t } = useAppTranslation('components/editor/testComponents')

  return (
    <div>
      {tests.map((test: Test) => (
        <p key={test.name}>
          name: {test.name}, status: {test.status}, output: {test.output}
        </p>
      ))}
    </div>
  )
}

// === end file ===

// === file: ../components/editor/testComponents/TestsGroupedByStatusList.tsx ===
// i18n-key-prefix: testsGroupedByStatusList
// i18n-namespace: components/editor/testComponents
import React from 'react'
import { TestStatus, Test } from '../types'
import { GraphicalIcon } from '../../common/GraphicalIcon'
import { TestsGroup, TestWithToggle } from './TestsGroup'
import pluralize from 'pluralize'
import { TestSummary } from './TestSummary'
import { useAppTranslation } from '@/i18n/useAppTranslation'

const Tests = ({
  tests,
  language,
}: {
  tests: TestWithToggle[]
  language: string
}): JSX.Element => {
  return (
    <>
      {tests.map((test, i) => (
        <TestSummary
          key={i}
          test={test}
          defaultOpen={test.defaultOpen}
          language={language}
        />
      ))}
    </>
  )
}

const Title = ({
  status,
  tests,
}: {
  status: string
  tests: TestWithToggle[]
}): JSX.Element => {
  const { t } = useAppTranslation('components/editor/testComponents')

  return (
    <>
      {tests.length} {pluralize(t('testsGroupedByStatusList.test'), tests.length)}{' '}
      {t(`testsGroupedByStatusList.${status}`)}
    </>
  )
}

export function TestsGroupedByStatusList({
  tests,
  language,
}: {
  tests: Test[]
  language: string
}): JSX.Element {
  const { t } = useAppTranslation('components/editor/testComponents')

  const testsWithIndex = tests.map((test, i) => ({ index: i + 1, ...test }))
  const passed: TestWithToggle[] = testsWithIndex
    .filter((test) => test.status === TestStatus.PASS)
    .map((test) => {
      return { ...test, defaultOpen: false }
    })

  const failed: TestWithToggle[] = testsWithIndex
    .filter(
      (test) =>
        test.status === TestStatus.FAIL || test.status === TestStatus.ERROR
    )
    .map((test, i) => {
      return { ...test, defaultOpen: i === 0 }
    })

  return (
    <div className="tests-grouped-by-status">
      <TestsGroup tests={passed}>
        <TestsGroup.Header>
          <GraphicalIcon icon="passed-check-circle" className="indicator" />
          <Title tests={passed} status="passed" />
          <GraphicalIcon icon="chevron-right" className="--closed-icon" />
          <GraphicalIcon icon="chevron-down" className="--open-icon" />
        </TestsGroup.Header>
        <Tests tests={passed} language={language} />
      </TestsGroup>
      <TestsGroup tests={failed} open={true}>
        <TestsGroup.Header>
          <GraphicalIcon icon="failed-check-circle" className="indicator" />
          <Title tests={failed} status="failed" />
          <GraphicalIcon icon="chevron-right" className="--closed-icon" />
          <GraphicalIcon icon="chevron-down" className="--open-icon" />
        </TestsGroup.Header>
        <Tests tests={failed} language={language} />
      </TestsGroup>
    </div>
  )
}

// === end file ===

// === file: ../components/editor/testComponents/TestRunSummaryContainer.tsx ===
// i18n-key-prefix: testRunSummaryContainer
// i18n-namespace: components/editor/testComponents
import React, { useEffect, useCallback, useRef } from 'react'
import { TestRun, TestRunner, TestRunStatus } from '../types'
import { TestRunChannel } from '../../../channels/testRunChannel'
import { fetchJSON } from '../../../utils/fetch-json'
import { useRequestQuery } from '../../../hooks/request-query'
import { TestRunSummary } from './TestRunSummary'
import { useAppTranslation } from '@/i18n/useAppTranslation'

const REFETCH_INTERVAL = 2000

export const TestRunSummaryContainer = ({
  testRun,
  testRunner,
  timeout,
  onUpdate,
  onSubmit,
  isSubmitDisabled,
  cancelLink,
}: {
  testRun: TestRun
  testRunner: TestRunner
  timeout: number
  onUpdate: (testRun: TestRun) => void
  onSubmit: () => void
  isSubmitDisabled: boolean
  cancelLink: string
}): JSX.Element | null => {
  const { t } = useAppTranslation('components/editor/testComponents')

  const { data } = useRequestQuery<{ testRun: TestRun }>(
    [`test-run-${testRun.submissionUuid}`],
    {
      endpoint: testRun.links.self,
      options: {
        enabled: testRun.submissionUuid !== 'faux-submission',
        refetchInterval:
          testRun.status === TestRunStatus.QUEUED ? REFETCH_INTERVAL : false,
      },
    }
  )
  const setTestRun = useCallback(
    (testRun) => {
      onUpdate(testRun)
    },
    [onUpdate]
  )
  const channel = useRef<TestRunChannel | undefined>()
  const timer = useRef<number | undefined>()
  const handleQueued = useCallback(() => {
    clearTimeout(timer.current)

    timer.current = window.setTimeout(() => {
      setTestRun({ ...testRun, status: TestRunStatus.TIMEOUT })
      timer.current = undefined
    }, timeout)
  }, [setTestRun, JSON.stringify(testRun), timeout])

  const cancel = useCallback(() => {
    setTestRun({ ...testRun, status: TestRunStatus.CANCELLED })

    fetchJSON(cancelLink, { method: 'PATCH' })
  }, [cancelLink, setTestRun, JSON.stringify(testRun)])

  useEffect(() => {
    if (!data || !data.testRun) {
      return
    }

    setTestRun(data.testRun)
  }, [JSON.stringify(data), setTestRun])

  useEffect(() => {
    switch (testRun.status) {
      case TestRunStatus.QUEUED:
        if (testRun.submissionUuid !== 'faux-submission') {
          handleQueued()
        }
        break
      default:
        clearTimeout(timer.current)
        channel.current?.disconnect()
        break
    }
  }, [handleQueued, testRun.status, testRun.submissionUuid])

  useEffect(() => {
    channel.current = new TestRunChannel(testRun, (updatedTestRun: TestRun) => {
      if (testRun.status !== TestRunStatus.QUEUED) {
        return
      }

      setTestRun(updatedTestRun)
    })

    return () => channel.current?.disconnect()
  }, [setTestRun, JSON.stringify(testRun)])

  useEffect(() => {
    return () => {
      channel.current?.disconnect()
    }
  }, [channel])

  useEffect(() => {
    return () => {
      clearTimeout(timer.current)
    }
  }, [timer])

  return (
    <TestRunSummary
      testRun={testRun}
      testRunner={testRunner}
      onSubmit={onSubmit}
      isSubmitDisabled={isSubmitDisabled}
      onCancel={cancel}
      showSuccessBox={true}
    />
  )
}

// === end file ===

// === file: ../components/editor/testComponents/TestsGroup.tsx ===
// i18n-key-prefix: testsGroup
// i18n-namespace: components/editor/testComponents
import React from 'react'
import { Test } from '../types'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type TestWithToggle = Test & { defaultOpen: boolean }

export const TestsGroup = ({
  open = false,
  tests,
  children,
}: {
  open?: boolean
  tests: Test[]
  children: React.ReactNode
}): JSX.Element | null => {
  const { t } = useAppTranslation('components/editor/testComponents')

  if (tests.length === 0) {
    return null
  }

  return (
    <details open={open} className="tests-group c-details">
      {children}
    </details>
  )
}

TestsGroup.Header = ({
  children,
}: {
  children: React.ReactNode
}): JSX.Element => (
  <summary className="tests-group-summary">
    <div className="--summary-inner">{children}</div>
  </summary>
)

// === end file ===

// === file: ../components/editor/testComponents/TestSummary.tsx ===
// i18n-key-prefix: testSummary
// i18n-namespace: components/editor/testComponents
import React, { useCallback } from 'react'
import { TestStatus, Test } from '../types'
import { GraphicalIcon } from '../../common/GraphicalIcon'
import { useHighlighting } from '../../../utils/highlight'
import { useAppTranslation } from '@/i18n/useAppTranslation'

const statusLabels = {
  [TestStatus.PASS]: 'Passed',
  [TestStatus.FAIL]: 'Failed',
  [TestStatus.ERROR]: 'Failed',
}
const messageLabels = {
  [TestStatus.PASS]: null,
  [TestStatus.FAIL]: 'Test Failure',
  [TestStatus.ERROR]: 'Test Error',
}

export function TestSummary({
  test,
  defaultOpen,
  language,
}: {
  test: Test
  defaultOpen: boolean
  language: string
}): JSX.Element => {
  const { t } = useAppTranslation('components/editor/testComponents')

  const isPresent = useCallback((str) => {
    return str !== undefined && str !== null && str !== ''
  }, [])

  const testCodeRef = useHighlighting<HTMLPreElement>()

  return (
    <details
      className={`c-details c-test-summary ${test.status}`}
      open={defaultOpen}
    >
      <summary className="--summary">
        <div className="--summary-inner">
          <div className="--status">
            <div className="--dot" />
            <span>{t(`testSummary.${statusLabels[test.status].toLowerCase()}`)}</span>
          </div>
          <div className="--summary-details">
            <div className="--summary-idx">{t('testSummary.test')} {test.index}</div>
            <div className="--summary-name">{test.name}</div>
          </div>
          <GraphicalIcon icon="chevron-right" className="--closed-icon" />
          <GraphicalIcon icon="chevron-down" className="--open-icon" />
        </div>
      </summary>
      <div className="--explanation">
        {isPresent(test.testCode) ? (
          <div className="--info">
            <h3>{t('testSummary.codeRun')}</h3>
            <pre ref={testCodeRef}>
              <code className={language}>{test.testCode}</code>
            </pre>
          </div>
        ) : null}
        {isPresent(test.message) ? (
          <div className="--info">
            <h3>{t(`testSummary.${messageLabels[test.status].toLowerCase()}`)}</h3>
            <pre dangerouslySetInnerHTML={{ __html: test.messageHtml }} />
          </div>
        ) : null}
        {isPresent(test.output) ? (
          <div className="--info">
            <h3>{t('testSummary.yourOutput')}</h3>
            <pre dangerouslySetInnerHTML={{ __html: test.outputHtml }} />
          </div>
        ) : null}
      </div>
    </details>
  )
}

// === end file ===

// === file: ../components/editor/testComponents/TestContentWrapper.tsx ===
// i18n-key-prefix: testContentWrapper
// i18n-namespace: components/editor/testComponents
import React, { useState, useContext, useCallback, createContext } from 'react'
import { TabContext, Tab } from '../../common'
import { TestFile } from '../../types'
import { TabsContext } from '../FileEditorCodeMirror'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export const TestTabContext = createContext<TabContext>({
  current: '',
  switchToTab: () => null,
})

type TestContentContextType = {
  testTab: { filename: string; content: string }
  setTestTab: (file: TestFile) => void
  testFiles: readonly TestFile[]
  tabContext: React.Context<TabContext>
  testTabGroupCss?: string
}

export const TestContentContext = createContext<TestContentContextType>({
  testTab: { filename: '', content: '' },
  setTestTab: () => null,
  testFiles: [],
  tabContext: TabsContext,
  testTabGroupCss: '',
})

export function TestContentWrapper({
  testFiles,
  children,
  tabContext,
  testTabGroupCss,
}: {
  children: React.ReactNode
} & Pick<
  TestContentContextType,
  'testTabGroupCss' | 'tabContext' | 'testFiles'
>): JSX.Element {
  const { t } = useAppTranslation('components/editor/testComponents')

  const [testTab, setTestTab] = useState<TestFile>(testFiles[0])

  return (
    <TestContentContext.Provider
      value={{ testTab, setTestTab, tabContext, testFiles, testTabGroupCss }}
    >
      <TabContextWrapper>{children}</TabContextWrapper>
    </TestContentContext.Provider>
  )
}

function TabContextWrapper({ children }: { children: React.ReactNode }) {
  const { t } = useAppTranslation('components/editor/testComponents')

  const { testTab, setTestTab, tabContext, testFiles, testTabGroupCss } =
    useContext(TestContentContext)
  const { current: currentTab } = useContext(tabContext)

  const switchToTab = useCallback(
    (filename: string) => {
      const testFile = testFiles.find((f) => f.filename === filename)
      if (!testFile) {
        throw new Error(t('testContentWrapper.fileNotFound'))
      } else {
        setTestTab(testFile)
      }
    },
    [setTestTab, testFiles, t]
  )

  return (
    <TestTabContext.Provider
      value={{
        current: testTab.filename,
        switchToTab,
      }}
    >
      {testFiles.length > 1 && currentTab === 'tests' ? (
        <div className={`c-test-tabs ${testTabGroupCss}`}>
          {testFiles.map((file) => (
            <Tab
              context={TestTabContext}
              key={file.filename}
              id={file.filename}
            >
              {file.filename}
            </Tab>
          ))}
        </div>
      ) : null}
      <div className="border-t-1 border-borderColor7">{children}</div>
    </TestTabContext.Provider>
  )
}

// === end file ===

