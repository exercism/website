```ts
// i18n
export default {
  "revealedBadge.name": "{{badgeName}}",
  "revealedBadge.description": "{{badgeDescription}}",
  "contributionResults.showingContributions": "Showing {{totalCount}} {{contributionLabel}}",
  "overview.learningSection": "Learning",
  "overview.mentoringSection": "Mentoring",
  "overview.contributingSection": "Contributing",
  "overview.badgesSection": "Badges",
  "badgesList.searchByBadgeNameOrDescription": "Search by badge name or description",
  "badgeResults.showingBadges": "Showing {{totalCount}} {{badgeLabel}}",
  "journeyPage.categoryTitle": "{{categoryTitle}}",
  "solution.inTrack": "in",
  "solution.completed": "Completed",
  "solution.published": "Published",
  "solution.thereIsANewerVersionOfTheExerciseVisitTheExercisePageToUpgrade": "There is a newer version of this exercise. Visit the exercise page to upgrade to the latest version.",
  "solution.passesTestsOfTheLatestVersionOfTheExercise": "Passes tests of the latest version of the exercise",
  "solution.thisSolutionFailsTheTestsOfTheLatestVersionOfTheExerciseTryUpdatingTheExerciseAndCheckingItLocallyOrInTheOnlineEditor": "This solution fails the tests of the latest version of this exercise. Try updating the exercise and checking it locally or in the online editor.",
  "solution.failedTestsOfTheLatestVersionOfTheExercise": "Failed tests of the latest version of the exercise",
  "solution.iterations": "{{numIterations}} {{iterationLabel}}",
  "solution.lines": "{{numLoc}} lines",
  "solution.views": "{{numViews}} {{viewLabel}}",
  "solution.lastSubmitted": "Last submitted {{lastIteratedAt}}",
  "solutionsList.searchByExerciseOrTrackName": "Search by exercise or track name",
  "solutionsList.showingSolutions": "Showing {{totalCount}} {{solutionLabel}}",
  "solutionsList.resetFilters": "Reset filters",
  "contributionsList.searchByContributionName": "Search by contribution name",
  "contribution.generic": "Generic",
  "unrevealedBadge.unrevealed": "Unrevealed",
  "unrevealedBadge.clickTapToReveal": "Click/tap to reveal",
  "contribution.in": "in"
}

// modified_files
// === file: ../components/journey/RevealedBadge.tsx ===
import React, { useState } from 'react'
import { BadgeMedallion } from '../common/BadgeMedallion'
import { Badge as BadgeProps } from '../types'
import { BadgeModal } from '../modals/BadgeModal'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export const RevealedBadge = ({
  badge,
}: {
  badge: BadgeProps
}): JSX.Element => {
  const { t } = useAppTranslation('components/journey')
  const [open, setOpen] = useState(false)
  return (
    <React.Fragment>
      <button className="c-badge" onClick={() => setOpen(!open)}>
        <BadgeMedallion badge={badge} />
        <div className="--info">
          <div className="--name">{badge.name}</div>
          <div className="--desc">{badge.description}</div>
        </div>
      </button>
      <BadgeModal
        badge={badge}
        open={open}
        onClose={() => {
          setOpen(false)
        }}
      />
    </React.Fragment>
  )
}

// === end file ===
// === file: ../components/journey/ContributionResults.tsx ===
import React, { useState, useCallback } from 'react'
import { Contribution } from './Contribution'
import pluralize from 'pluralize'
import { MarkAllAsSeenModal } from './contribution-results/MarkAllAsSeenModal'
import { MarkAllAsSeenButton } from './contribution-results/MarkAllAsSeenButton'
import { APIResult } from './ContributionsList'
import { QueryKey, useQueryClient } from '@tanstack/react-query'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type Order = 'newest_first' | 'oldest_first'

export const ContributionResults = ({
  cacheKey,
  data,
}: {
  cacheKey: QueryKey
  data: APIResult
}): JSX.Element => {
  const { t } = useAppTranslation('components/journey')
  const queryClient = useQueryClient()
  const [modalOpen, setModalOpen] = useState(false)

  const handleModalOpen = useCallback(() => {
    setModalOpen(true)
  }, [])

  const handleModalClose = useCallback(() => {
    setModalOpen(false)
  }, [])

  const handleSuccess = useCallback(
    (response: APIResult) => {
      const oldData = queryClient.getQueryData<APIResult>(cacheKey)

      queryClient.setQueryData(cacheKey, {
        ...oldData,
        meta: { ...oldData?.meta, unseenTotal: response.meta.unseenTotal },
      })
    },
    [cacheKey, queryClient]
  )

  return (
    <div>
      <div className="results-title-bar">
        <h3>
          {t('contributionResults.showingContributions', {
            totalCount: data.meta.totalCount,
            contributionLabel: pluralize('contribution', data.meta.totalCount),
          })}
        </h3>
        <MarkAllAsSeenButton
          onClick={handleModalOpen}
          unseenTotal={data.meta.unseenTotal}
        />
      </div>
      <div className="reputation-tokens">
        {data.results.map((contribution) => {
          return <Contribution {...contribution} key={contribution.uuid} />
        })}
      </div>
      <MarkAllAsSeenModal
        endpoint={data.meta.links.markAllAsSeen}
        open={modalOpen}
        onSuccess={handleSuccess}
        onClose={handleModalClose}
        unseenTotal={data.meta.unseenTotal}
      />
    </div>
  )
}

// === end file ===
// === file: ../components/journey/Overview.tsx ===
import React from 'react'
import {
  LearningSection,
  Props as LearningSectionProps,
} from './overview/LearningSection'
import {
  MentoringSection,
  Props as MentoringSectionProps,
} from './overview/MentoringSection'
import {
  ContributingSection,
  Props as ContributingSectionProps,
} from './overview/ContributingSection'
import {
  BadgesSection,
  Props as BadgesSectionProps,
} from './overview/BadgesSection'
import { usePaginatedRequestQuery, Request } from '../../hooks/request-query'
import { ResultsZone } from '../ResultsZone'
import { FetchingBoundary } from '../FetchingBoundary'
import { useAppTranslation } from '@/i18n/useAppTranslation'
import {
  MentoringTotals,
  MentoringRanks,
  MentoredTrackProgressList,
  MentoredTrackProgress,
  TrackProgress,
  TrackProgressList,
} from './types'
import { TrackContribution, Badge, BadgeList } from '../types'

type JourneyOverview = {
  learning: { tracks: readonly TrackProgress[] } & Omit<
    LearningSectionProps,
    'tracks'
  >
  mentoring: {
    tracks: readonly MentoredTrackProgress[]
    totals: MentoringTotals
    ranks: MentoringRanks
  } & Omit<MentoringSectionProps, 'tracks'>
  contributing: { tracks: readonly TrackContribution[] } & Omit<
    ContributingSectionProps,
    'tracks'
  >
  badges: { badges: readonly Badge[] } & Omit<BadgesSectionProps, 'badges'>
}

const DEFAULT_ERROR = new Error('Unable to load journey overview')

const formatData = ({ overview }: { overview: JourneyOverview }) => {
  return {
    overview: {
      learning: {
        ...overview.learning,
        tracks: new TrackProgressList({ items: overview.learning.tracks }),
      },
      mentoring: {
        ...overview.mentoring,
        tracks: new MentoredTrackProgressList({
          items: overview.mentoring.tracks,
          totals: overview.mentoring.totals,
          ranks: overview.mentoring.ranks,
        }),
      },
      contributing: {
        ...overview.contributing,
        tracks: overview.contributing.tracks.map(
          (track) => new TrackContribution(track)
        ),
      },
      badges: {
        ...overview.badges,
        badges: new BadgeList({ items: overview.badges.badges }),
      },
    },
  }
}

export const Overview = ({
  request,
  isEnabled,
}: {
  request: Request
  isEnabled: boolean
}): JSX.Element => {
  const { t } = useAppTranslation('components/journey')
  const {
    status,
    data: resolvedData,
    isFetching,
    error,
  } = usePaginatedRequestQuery<{
    overview: JourneyOverview
  }>(['journey-overview'], {
    ...request,
    options: { ...request.options, enabled: isEnabled },
  })
  const formattedData = resolvedData ? formatData(resolvedData) : null

  return (
    <article className="overview-tab theme-dark">
      <ResultsZone isFetching={isFetching}>
        <FetchingBoundary
          status={status}
          error={error}
          defaultError={DEFAULT_ERROR}
        >
          {formattedData ? (
            <React.Fragment>
              <div className="md-container">
                <LearningSection
                  {...formattedData.overview.learning}
                  title={t('overview.learningSection')}
                />
                <MentoringSection
                  {...formattedData.overview.mentoring}
                  title={t('overview.mentoringSection')}
                />
              </div>
              <div className="lg-container">
                <ContributingSection
                  {...formattedData.overview.contributing}
                  title={t('overview.contributingSection')}
                />
              </div>
              <div className="md-container">
                <BadgesSection
                  {...formattedData.overview.badges}
                  title={t('overview.badgesSection')}
                />
              </div>
            </React.Fragment>
          ) : null}
        </FetchingBoundary>
      </ResultsZone>
    </article>
  )
}

// === end file ===
// === file: ../components/journey/BadgesList.tsx ===
import React, { useState, useEffect } from 'react'
import { scrollToTop } from '@/utils/scroll-to-top'
import { usePaginatedRequestQuery, type Request } from '@/hooks/request-query'
import { useHistory, removeEmpty } from '@/hooks/use-history'
import { useList } from '@/hooks/use-list'
import { ResultsZone } from '@/components/ResultsZone'
import { Pagination } from '@/components/common'
import { FetchingBoundary } from '@/components/FetchingBoundary'
import { BadgeResults } from './BadgeResults'
import { OrderSwitcher } from './badges-list/OrderSwitcher'
import type { PaginatedResult, Badge } from '@/components/types'
import type { QueryKey } from '@tanstack/react-query'
import { useAppTranslation } from '@/i18n/useAppTranslation'

const DEFAULT_ORDER = 'unrevealed_first'
const DEFAULT_ERROR = new Error('Unable to load badge list')

export const BadgesList = ({
  request: initialRequest,
  isEnabled,
}: {
  request: Request
  isEnabled: boolean
}): JSX.Element => {
  const { t } = useAppTranslation('components/journey')
  const {
    request,
    setPage,
    setCriteria: setRequestCriteria,
    setOrder,
  } = useList(initialRequest)
  const [criteria, setCriteria] = useState(request.query?.criteria || '')
  const cacheKey: QueryKey = [
    'badges-list',
    request.endpoint,
    removeEmpty(request.query),
  ]
  const {
    status,
    data: resolvedData,
    isFetching,
    error,
  } = usePaginatedRequestQuery<PaginatedResult<Badge[]>>(cacheKey, {
    ...request,
    query: removeEmpty(request.query),
    options: { ...request.options, enabled: isEnabled },
  })

  useEffect(() => {
    const handler = setTimeout(() => {
      if (criteria === undefined || criteria === null) return
      setRequestCriteria(criteria)
    }, 200)

    return () => {
      clearTimeout(handler)
    }
  }, [setRequestCriteria, criteria])

  useHistory({ pushOn: removeEmpty(request.query) })

  useEffect(() => {
    scrollToTop('badges-list', 0, 'smooth')
  }, [])

  return (
    <article
      data-scroll-top-anchor="badges-list"
      className="badges-tab theme-dark"
    >
      <div className="md-container container">
        <div className="c-search-bar">
          <input
            className="--search"
            onChange={(e) => {
              setCriteria(e.target.value)
            }}
            value={criteria}
            placeholder={t('badgesList.searchByBadgeNameOrDescription')}
          />
          <OrderSwitcher
            value={request.query.order || DEFAULT_ORDER}
            setValue={setOrder}
          />
        </div>
        <ResultsZone isFetching={isFetching}>
          <FetchingBoundary
            status={status}
            error={error}
            defaultError={DEFAULT_ERROR}
          >
            {resolvedData ? (
              <React.Fragment>
                <BadgeResults data={resolvedData} cacheKey={cacheKey} />
                <Pagination
                  disabled={resolvedData === undefined}
                  current={request.query.page || 1}
                  total={resolvedData.meta.totalPages}
                  setPage={(p) => {
                    setPage(p)
                    scrollToTop('badges-list')
                  }}
                />
              </React.Fragment>
            ) : null}
          </FetchingBoundary>
        </ResultsZone>
      </div>
    </article>
  )
}

// === end file ===
// === file: ../components/journey/BadgeResults.tsx ===
import React from 'react'
import { RevealedBadge } from './RevealedBadge'
import { UnrevealedBadge } from './UnrevealedBadge'
import pluralize from 'pluralize'
import { Badge as BadgeProps, PaginatedResult } from '../types'
import { QueryKey } from '@tanstack/react-query'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type Order = 'unrevealed_first' | 'newest_first' | 'oldest_first'

export const BadgeResults = ({
  data,
  cacheKey,
}: {
  data: PaginatedResult<BadgeProps[]>
  cacheKey: QueryKey
}): JSX.Element => {
  const { t } = useAppTranslation('components/journey')
  return (
    <div>
      <div className="results-title-bar">
        <h3>
          {t('badgeResults.showingBadges', {
            totalCount: data.meta.totalCount,
            badgeLabel: pluralize('badge', data.meta.totalCount),
          })}
        </h3>
      </div>
      <div className="badges">
        {data.results.map((badge) => {
          return badge.isRevealed ? (
            <RevealedBadge
              badge={badge}
              key={badge.uuid}
              badgeName={badge.name}
              badgeDescription={badge.description}
            />
          ) : (
            <UnrevealedBadge
              badge={badge}
              cacheKey={cacheKey}
              key={badge.uuid}
            />
          )
        })}
      </div>
    </div>
  )
}

// === end file ===
// === file: ../components/journey/JourneyPage.tsx ===
import React, {
  useEffect,
  useState,
  useCallback,
  createContext,
  useRef,
} from 'react'
import { GraphicalIcon } from '../common'
import { type TabContext, Tab } from '../common/Tab'
import { ContributionsList } from './ContributionsList'
import { SolutionsList } from './SolutionsList'
import { BadgesList } from './BadgesList'
import { Overview } from './Overview'
import type { Request } from '@/hooks/request-query'
import { useAppTranslation } from '@/i18n/useAppTranslation'

type CategoryId = 'solutions' | 'reputation'

const TabsContext = createContext<TabContext>({
  current: '',
  switchToTab: () => null,
})

export type Category = {
  id: string
  title: string
  icon: string
  path: string
  request: Request
}

export default function JourneyPage({
  defaultCategory,
  categories,
}: {
  defaultCategory: CategoryId
  categories: readonly Category[]
}): JSX.Element {
  const { t } = useAppTranslation('components/journey')
  const isMounted = useRef(false)
  const [currentCategory, setCurrentCategory] = useState<Category>(() => {
    const category = categories.find((c) => c.id === defaultCategory)

    if (!category) {
      throw new Error('Category not found')
    }

    return category
  })

  const switchToTab = useCallback(
    (id: string) => {
      const category = categories.find((c) => c.id === id)

      if (!category) {
        throw new Error('Category not found')
      }

      setCurrentCategory(category)
    },
    [categories]
  )

  useEffect(() => {
    if (!isMounted.current) {
      isMounted.current = true
      return
    }

    history.pushState(history.state, '', currentCategory.path)
  }, [currentCategory])

  return (
    <TabsContext.Provider
      value={{ current: currentCategory.id, switchToTab: switchToTab }}
    >
      <div className="tabs theme-dark">
        {categories.map((category) => {
          return (
            <Tab key={category.id} context={TabsContext} id={category.id}>
              <GraphicalIcon icon={category.icon} />
              {t('journeyPage.categoryTitle', { categoryTitle: category.title })}
            </Tab>
          )
        })}
      </div>
      {categories.map((category) => {
        return (
          <Tab.Panel id={category.id} context={TabsContext} key={category.id}>
            {category.id === 'overview' ? (
              <Overview
                isEnabled={currentCategory.id === 'overview'}
                request={category.request}
              />
            ) : null}
            {category.id === 'solutions' ? (
              <SolutionsList
                isEnabled={currentCategory.id === 'solutions'}
                request={category.request}
              />
            ) : null}
            {category.id === 'reputation' ? (
              <ContributionsList
                isEnabled={currentCategory.id === 'reputation'}
                request={category.request}
              />
            ) : null}
            {category.id === 'badges' ? (
              <BadgesList
                isEnabled={currentCategory.id === 'badges'}
                request={category.request}
              />
            ) : null}
          </Tab.Panel>
        )
      })}
    </TabsContext.Provider>
  )
}

// === end file ===
// === file: ../components/journey/Solution.tsx ===
import React from 'react'
import { fromNow } from '../../utils/time'
import { GraphicalIcon, TrackIcon, ExerciseIcon, Icon } from '../common'
import { GenericTooltip } from '../misc/ExercismTippy'
import pluralize from 'pluralize'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type SolutionProps = {
  uuid: string
  privateUrl: string
  status: string
  publishedIterationHeadTestsStatus: string
  numViews?: number
  numStars: number
  numComments: number
  numIterations: number
  numLoc?: string
  lastIteratedAt: string
  isOutOfDate: boolean
  exercise: {
    title: string
    iconUrl: string
  }
  track: {
    title: string
    iconUrl: string
  }
}

export const Solution = ({
  privateUrl,
  status,
  publishedIterationHeadTestsStatus,
  numViews,
  numStars,
  numComments,
  numIterations,
  numLoc,
  lastIteratedAt,
  exercise,
  track,
  isOutOfDate,
}: SolutionProps): JSX.Element => {
  const { t } = useAppTranslation('components/journey')
  return (
    <a href={privateUrl} className="solution">
      <div className="main">
        <div className="exercise">
          <ExerciseIcon iconUrl={exercise.iconUrl} />
          <div className="info">
            <div className="flex items-center mb-8">
              <div className="exercise-title">{exercise.title}</div>

              {isOutOfDate ? (
                <GenericTooltip content={t('solution.thereIsANewerVersionOfTheExerciseVisitTheExercisePageToUpgrade')}>
                  <div>
                    <Icon
                      icon="warning"
                      alt={t('solution.thereIsANewerVersionOfTheExerciseVisitTheExercisePageToUpgrade')}
                      className="--out-of-date"
                    />
                  </div>
                </GenericTooltip>
              ) : null}

              {publishedIterationHeadTestsStatus === 'passed' ? (
                <Icon
                  icon="golden-check"
                  alt={t('solution.passesTestsOfTheLatestVersionOfTheExercise')}
                  className="head-tests-status --passed"
                />
              ) : publishedIterationHeadTestsStatus === 'failed' ||
                publishedIterationHeadTestsStatus === 'errored' ? (
                <GenericTooltip content={t('solution.thisSolutionFailsTheTestsOfTheLatestVersionOfTheExerciseTryUpdatingTheExerciseAndCheckingItLocallyOrInTheOnlineEditor')}>
                  <div>
                    <Icon
                      icon="cross-circle"
                      alt={t('solution.failedTestsOfTheLatestVersionOfTheExercise')}
                      className="head-tests-status --failed"
                    />
                  </div>
                </GenericTooltip>
              ) : null}
            </div>
            <div className="extra">
              <div className="track">
                {t('solution.inTrack')}
                <TrackIcon iconUrl={track.iconUrl} title={track.title} />
                <div className="track-title">{track.title}</div>
              </div>
              {status === 'completed' ? (
                <div className="status">
                  <GraphicalIcon icon="completed-check-circle" />
                  {t('solution.completed')}
                </div>
              ) : status === 'published' ? (
                <div className="status">
                  <GraphicalIcon icon="completed-check-circle" />
                  {t('solution.published')}
                </div>
              ) : (
                <></>
              )}
            </div>
          </div>
        </div>
        <div className="stats">
          <div className="stat">
            <GraphicalIcon icon="iteration" />
            {numIterations} {t('solution.iterations', { numIterations: numIterations, iterationLabel: pluralize('iteration', numIterations) })}
          </div>
          {numLoc ? (
            <div className="stat">
              <GraphicalIcon icon="loc" />
              {t('solution.lines', { numLoc: numLoc })}
            </div>
          ) : null}
          {numViews ? (
            <div className="stat">
              <GraphicalIcon icon="views" />
              {numViews} {t('solution.views', { numViews: numViews, viewLabel: pluralize('view', numViews) })}
            </div>
          ) : null}
        </div>
        {lastIteratedAt ? (
          <time className="iterated-at" dateTime={lastIteratedAt}>
            {t('solution.lastSubmitted', { lastIteratedAt: fromNow(lastIteratedAt) })}
          </time>
        ) : null}
      </div>
      <div className="counts">
        <div className="count">
          <GraphicalIcon icon="star" />
          <div className="num">{numStars}</div>
        </div>
        <div className="count">
          <GraphicalIcon icon="comment" />
          <div className="num">{numComments}</div>
        </div>
      </div>
    </a>
  )
}

// === end file ===
// === file: ../components/journey/SolutionsList.tsx ===
import React, { useState, useCallback, useEffect } from 'react'
import pluralize from 'pluralize'
import { scrollToTop } from '@/utils/scroll-to-top'
import { SolutionProps, Solution } from './Solution'
import { usePaginatedRequestQuery, type Request } from '@/hooks/request-query'
import { removeEmpty, useHistory } from '@/hooks/use-history'
import { useList } from '@/hooks/use-list'
import { ResultsZone } from '@/components/ResultsZone'
import { Pagination, GraphicalIcon } from '@/components/common'
import { FetchingBoundary } from '@/components/FetchingBoundary'
import {
  MentoringStatus,
  SyncStatus,
  TestsStatus,
  HeadTestsStatus,
  SolutionFilter,
  OrderSwitcher,
  ExerciseStatus,
} from './solutions-list'
import type { PaginatedResult } from '@/components/types'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export type Order = 'newest_first' | 'oldest_first'

const DEFAULT_ORDER = 'newest_first'
const DEFAULT_ERROR = new Error('Unable to load solutions')

export const SolutionsList = ({
  request: initialRequest,
  isEnabled,
}: {
  request: Request
  isEnabled: boolean
}): JSX.Element => {
  const { t } = useAppTranslation('components/journey')
  const {
    request,
    setPage,
    setCriteria: setRequestCriteria,
    setQuery,
    setOrder,
  } = useList(initialRequest)
  const [criteria, setCriteria] = useState(request.query?.criteria)
  const cacheKey = [
    'contributions-list',
    request.endpoint,
    removeEmpty(request.query),
  ]
  const {
    status,
    data: resolvedData,
    isFetching,
    error,
  } = usePaginatedRequestQuery<PaginatedResult<SolutionProps[]>>(cacheKey, {
    ...request,
    query: removeEmpty(request.query),
    options: { ...request.options, enabled: isEnabled },
  })

  useEffect(() => {
    const handler = setTimeout(() => {
      if (criteria === undefined || criteria === null) return
      setRequestCriteria(criteria)
    }, 200)

    return () => {
      clearTimeout(handler)
    }
  }, [setRequestCriteria, criteria])

  useHistory({ pushOn: removeEmpty(request.query) })

  const handleApply = useCallback(
    (
      status: ExerciseStatus,
      mentoringStatus: MentoringStatus,
      syncStatus: SyncStatus,
      testsStatus: TestsStatus,
      headTestsStatus: HeadTestsStatus
    ) => {
      setQuery({
        ...request.query,
        page: undefined,
        status: status,
        mentoringStatus: mentoringStatus,
        syncStatus: syncStatus,
        testsStatus: testsStatus,
        headTestsStatus: headTestsStatus,
      })
    },
    [request.query, setQuery]
  )

  const handleReset = useCallback(() => {
    setQuery({
      ...request.query,
      page: undefined,
      status: undefined,
      mentoringStatus: undefined,
      syncStatus: undefined,
      testsStatus: undefined,
      headTestsStatus: undefined,
    })
  }, [request.query, setQuery])

  return (
    <article
      data-scroll-top-anchor="solutions-list"
      className="solutions-tab theme-dark"
    >
      <div className="c-search-bar">
        <div className="md-container container">
          <input
            className="--search"
            onChange={(e) => {
              setCriteria(e.target.value)
            }}
            value={criteria || ''}
            placeholder={t('solutionsList.searchByExerciseOrTrackName')}
          />
          <SolutionFilter request={request} onApply={handleApply} />
          <OrderSwitcher
            value={(request.query.order || DEFAULT_ORDER) as Order}
            setValue={setOrder}
          />
        </div>
      </div>
      <div className="md-container container">
        <ResultsZone isFetching={isFetching}>
          <FetchingBoundary
            status={status}
            error={error}
            defaultError={DEFAULT_ERROR}
          >
            {resolvedData ? (
              <React.Fragment>
                <div>
                  <div className="results-title-bar">
                    <h3>
                      {t('solutionsList.showingSolutions', {
                        totalCount: resolvedData.meta.totalCount,
                        solutionLabel: pluralize('solution', resolvedData.meta.totalCount),
                      })}
                    </h3>
                    <button
                      type="button"
                      onClick={handleReset}
                      className="btn-link"
                    >
                      <GraphicalIcon icon="reset" />
                      <span>{t('solutionsList.resetFilters')}</span>
                    </button>
                  </div>
                  <div className="solutions">
                    {resolvedData.results.map((solution) => {
                      return <Solution {...solution} key={solution.uuid} />
                    })}
                  </div>
                </div>
                <Pagination
                  disabled={resolvedData === undefined}
                  current={request.query.page || 1}
                  total={resolvedData.meta.totalPages}
                  setPage={(p) => {
                    setPage(p)
                    scrollToTop('solutions-list')
                  }}
                />
              </React.Fragment>
            ) : null}
          </FetchingBoundary>
        </ResultsZone>
      </div>
    </article>
  )
}

// === end file ===
// === file: ../components/journey/ContributionsList.tsx ===
import React, { useState, useCallback, useEffect } from 'react'
import { scrollToTop } from '@/utils/scroll-to-top'
import { ContributionResults } from './ContributionResults'
import { type Request, usePaginatedRequestQuery } from '@/hooks/request-query'
import { removeEmpty, useHistory } from '@/hooks/use-history'
import { useDeepMemo } from '@/hooks/use-deep-memo'
import { useList } from '@/hooks/use-list'
import { ResultsZone } from '@/components/ResultsZone'
import { Pagination } from '@/components/common'
import { FetchingBoundary } from '@/components/FetchingBoundary'
import type { Contribution } from '@/components/types'
import { CategorySelect } from './contributions-list/CategorySelect'
import { useAppTranslation } from '@/i18n/useAppTranslation'

const DEFAULT_ERROR = new Error('Unable to load contributions list')

export type APIResult = {
  results: Contribution[]
  meta: {
    currentPage: number
    totalPages: number
    totalCount: number
    links: {
      markAllAsSeen: string
    }
    unseenTotal: number
  }
}

export function ContributionsList({
  request: initialRequest,
  isEnabled,
}: {
  request: Request
  isEnabled: boolean
}): JSX.Element {
  const { t } = useAppTranslation('components/journey')
  const {
    request,
    setPage,
    setCriteria: setRequestCriteria,
    setQuery,
  } = useList(initialRequest)
  const [criteria, setCriteria] = useState(request.query?.criteria)
  const cacheKey = [
    'contributions-list',
    request.endpoint,
    removeEmpty(request.query),
  ]
  const {
    status,
    data: resolvedData,
    isFetching,
    error,
  } = usePaginatedRequestQuery<APIResult>(cacheKey, {
    ...request,
    query: removeEmpty(request.query),
    options: { ...request.options, enabled: isEnabled },
  })

  const requestQuery = useDeepMemo(request.query)
  const setCategory = useCallback(
    (category) => {
      setQuery({ ...requestQuery, category: category, page: undefined })
    },
    [requestQuery, setQuery]
  )

  useEffect(() => {
    const handler = setTimeout(() => {
      if (criteria === undefined || criteria === null) return
      setRequestCriteria(criteria)
    }, 200)

    return () => {
      clearTimeout(handler)
    }
  }, [setRequestCriteria, criteria])

  useHistory({ pushOn: removeEmpty(request.query) })

  return (
    <article
      data-scroll-top-anchor="contributions-list"
      className="reputation-tab theme-dark"
    >
      <div className="md-container container">
        <div className="c-search-bar">
          <input
            className="--search"
            onChange={(e) => {
              setCriteria(e.target.value)
            }}
            value={criteria || ''}
            placeholder={t('contributionsList.searchByContributionName')}
          />
          <CategorySelect
            value={request.query.category}
            setValue={setCategory}
          />
        </div>
        <ResultsZone isFetching={isFetching}>
          <FetchingBoundary
            status={status}
            error={error}
            defaultError={DEFAULT_ERROR}
          >
            {resolvedData ? (
              <React.Fragment>
                <ContributionResults data={resolvedData} cacheKey={cacheKey} />
                <Pagination
                  disabled={resolvedData === undefined}
                  current={request.query.page || 1}
                  total={resolvedData.meta.totalPages}
                  setPage={(p) => {
                    setPage(p)
                    scrollToTop('contributions-list')
                  }}
                />
              </React.Fragment>
            ) : null}
          </FetchingBoundary>
        </ResultsZone>
      </div>
    </article>
  )
}

// === end file ===
// === file: ../components/journey/Contribution.tsx ===
import React from 'react'
import { fromNow } from '@/utils/date'
import { GraphicalIcon, TrackIcon, Reputation } from '@/components/common'
import { missingExerciseIconErrorHandler } from '@/components/common/imageErrorHandler'
import { Contribution as ContributionProps } from '@/components/types'
import { useAppTranslation } from '@/i1