```ts
// i18n
export default {
}

// modified_files
// === file: ../components/mentoring/discussion/discussion-post-list/use-posts.tsx ===
import { useMemo } from 'react'
import { DiscussionPostProps } from '../DiscussionPost'
import { Iteration } from '../../../types'

export const usePosts = (
  iterations: readonly Iteration[]
): DiscussionPostProps[] => {
  return useMemo(() => {
    return iterations.reduce<DiscussionPostProps[]>((posts, iteration) => {
      return posts.concat(iteration.posts || [])
    }, [])
  }, [JSON.stringify(iterations)])
}

// end file

// === file: ../components/mentoring/discussion/discussion-post-list/use-list-trimming.tsx ===
import { Iteration } from '../../../types'

export const useListTrimming = <T extends Iteration>(iterations: T[]): T[] => {
  const startIteration = iterations.findIndex(
    (iteration) => iteration.posts && iteration.posts.length !== 0
  )

  return iterations.slice(startIteration)
}

// end file

// === file: ../components/mentoring/discussion/discussion-post-list/use-channel.tsx ===
import { useEffect } from 'react'
import { DiscussionPostChannel } from '../../../../channels/discussionPostChannel'

export const useChannel = (
  discussionUuid: string,
  onReceive: () => void
): void => {
  useEffect(() => {
    const channel = new DiscussionPostChannel(
      { discussionUuid: discussionUuid },
      onReceive
    )

    return () => {
      channel.disconnect()
    }
  }, [discussionUuid, onReceive])
}

// end file

// === file: ../components/mentoring/discussion/discussion-post-list/use-post-scrolling.tsx ===
import { useState, useEffect, useCallback, createRef } from 'react'
import { Iteration } from '../../../types'

type IntersectionStatus = {
  iteration: Iteration
  isIntersecting: boolean
}

export type IterationWithRef = Iteration & {
  ref: React.RefObject<HTMLDivElement>
}

export const usePostScrolling = ({
  iterations,
  onScroll,
}: {
  iterations: readonly Iteration[]
  onScroll: (iteration: Iteration) => void
}): { iterationsWithRef: IterationWithRef[] } => {
  const [iterationsWithRef, setIterationsWithRef] = useState<
    IterationWithRef[]
  >([])
  const [intersectionStatus, setIntersectionStatus] = useState<
    IntersectionStatus[]
  >([])

  const registerEntry = useCallback(
    (entries: IntersectionObserverEntry[]) => {
      setIntersectionStatus(
        iterationsWithRef.map((i) => {
          const matchingEntry = entries.find((e) => e.target === i.ref.current)

          return {
            iteration: i,
            isIntersecting: matchingEntry
              ? matchingEntry.isIntersecting
              : false,
          }
        })
      )
    },
    [iterationsWithRef]
  )

  useEffect(() => {
    setIterationsWithRef(
      iterations.map((iteration) => {
        return { ...iteration, ref: createRef<HTMLDivElement>() }
      })
    )
  }, [JSON.stringify(iterations)])

  useEffect(() => {
    const observer = new IntersectionObserver(registerEntry, {
      threshold: 1,
      root: null,
      rootMargin: '0px',
    })

    iterationsWithRef.forEach((i) => {
      if (!i.ref.current) {
        return
      }

      observer.observe(i.ref.current)
    })

    return () => {
      observer.disconnect()
    }
  }, [iterationsWithRef, registerEntry])

  useEffect(() => {
    const intersectingIteration = intersectionStatus.filter(
      (s) => s.isIntersecting
    )[0]

    if (!intersectingIteration) {
      return
    }

    onScroll(intersectingIteration.iteration)
  }, [intersectionStatus, onScroll])

  return { iterationsWithRef }
}

// end file
```