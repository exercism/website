```ts
// i18n
export default {
  "selectedTracksMessage.noTracksSelected": "No tracks selected",
  "selectedTracksMessage.tracksSelected": "{{numSelected}} {{pluralizedTrack}} selected",
  "trackCheckbox.trackSelected": "Track selected",
  "tracksList.noTracksFound": "No tracks found",
  "continueButton.continue": "Continue"
}

// modified_files
// === file: ../components/mentoring/track-selector/SelectedTracksMessage.tsx ===
import React from 'react'
import pluralize from 'pluralize'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export const SelectedTracksMessage = ({
  numSelected,
}: {
  numSelected: number
}): JSX.Element => {
  const { t } = useAppTranslation('components/mentoring/track-selector')
  const classNames = ['selected', numSelected === 0 ? 'none' : ''].filter(
    (name) => name !== ''
  )
  const message =
    numSelected === 0
      ? t('selectedTracksMessage.noTracksSelected')
      : t('selectedTracksMessage.tracksSelected', {
          numSelected,
          pluralizedTrack: pluralize('track', numSelected),
        })

  return <div className={classNames.join(' ')}>{message}</div>
}

// === end file ===

// === file: ../components/mentoring/track-selector/TrackCheckbox.tsx ===
import React from 'react'
import pluralize from 'pluralize'
import { Icon, TrackIcon } from '@/components/common'
import { MedianWaitTime } from '@/components/common/MedianWaitTime'
import { Track } from '../TrackSelector'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export const TrackCheckbox = ({
  slug,
  title,
  iconUrl,
  medianWaitTime,
  numSolutionsQueued,
  checked,
  onChange,
}: Track & {
  checked: boolean
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void
}): JSX.Element => {
  const { t } = useAppTranslation('components/mentoring/track-selector')

  return (
    <div className="track">
      <input
        type="checkbox"
        id={slug}
        checked={checked}
        onChange={onChange}
        aria-labelledby={`${slug}-label`}
      />
      <label className="track" htmlFor={slug} id={`${slug}-label`}>
        {checked ? (
          <div className="selected-icon">
            <Icon icon="checkmark" alt={t('trackCheckbox.trackSelected')} />
          </div>
        ) : null}
        <TrackIcon iconUrl={iconUrl} title={title} />
        <div className="title">{title}</div>
        <div className="info">
          <MedianWaitTime seconds={medianWaitTime} />
          {numSolutionsQueued} {pluralize('solution', numSolutionsQueued)}{' '}
          queued
        </div>
      </label>
    </div>
  )
}

// === end file ===

// === file: ../components/mentoring/track-selector/TracksList.tsx ===
import React, { useCallback } from 'react'
import { QueryStatus } from '@tanstack/react-query'
import { APIResponse, Track } from '../TrackSelector'
import { TrackCheckbox } from './TrackCheckbox'
import { FetchingBoundary } from '../../FetchingBoundary'
import { useAppTranslation } from '@/i18n/useAppTranslation'

const NoTracksFoundMessage = () => {
  const { t } = useAppTranslation('components/mentoring/track-selector')
  return <p>{t('tracksList.noTracksFound')}</p>
}

const TrackOptions = ({
  tracks,
  selected,
  setSelected,
}: {
  tracks: readonly Track[]
  selected: readonly string[]
  setSelected: (selected: string[]) => void
}) => {
  const handleChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>, id: string) => {
      if (e.target.checked) {
        setSelected([...selected, id])
      } else {
        setSelected(selected.filter((v) => v !== id))
      }
    },
    [selected, setSelected]
  )

  return (
    <React.Fragment>
      {tracks.map((track) => {
        return (
          <TrackCheckbox
            key={track.slug}
            {...track}
            checked={selected.includes(track.slug)}
            onChange={(e) => handleChange(e, track.slug)}
          />
        )
      })}
    </React.Fragment>
  )
}

const DEFAULT_ERROR = new Error('Unable to fetch tracks')

export const TracksList = ({
  status,
  error,
  selected,
  setSelected,
  data,
}: {
  status: QueryStatus
  error: Error | unknown
  selected: readonly string[]
  setSelected: (selected: string[]) => void
  data: APIResponse | undefined
}): JSX.Element | null => {
  return (
    <FetchingBoundary
      status={status}
      error={error}
      defaultError={DEFAULT_ERROR}
    >
      {data === undefined || data.tracks.length === 0 ? (
        <NoTracksFoundMessage />
      ) : (
        <TrackOptions
          tracks={data.tracks}
          selected={selected}
          setSelected={setSelected}
        />
      )}
    </FetchingBoundary>
  )
}

// === end file ===

// === file: ../components/mentoring/track-selector/SearchBar.tsx ===
import React, { useCallback } from 'react'

export const SearchBar = ({
  value,
  setValue,
}: {
  value: string
  setValue: (value: string) => void
}): JSX.Element => {
  const handleChange = useCallback(
    (e) => {
      setValue(e.target.value)
    },
    [setValue]
  )

  return <input className="--search" value={value} onChange={handleChange} />
}

// === end file ===

// === file: ../components/mentoring/track-selector/ContinueButton.tsx ===
import React from 'react'
import { useAppTranslation } from '@/i18n/useAppTranslation'

export const ContinueButton = (
  props: React.ButtonHTMLAttributes<HTMLButtonElement>
): JSX.Element => {
  const { t } = useAppTranslation('components/mentoring/track-selector')

  return (
    <button className="btn-primary btn-m" {...props}>
      <span>{t('continueButton.continue')}</span>
    </button>
  )
}

// === end file ===
```