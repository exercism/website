# frozen_string_literal: true

require "json"

# Input directory with your per-file TS translations
DIR = Rails.root.join("app/javascript/i18n/en")

# Output single TS file - the unified javascript-copy.ts
OUTPUT_TS = Rails.root.join("i18n/javascript-copy.ts")

# Output file for key conflicts
CONFLICTS_OUTPUT = Rails.root.join("i18n/key-conflicts.json")

# If you prefer to split by namespace (per file), set this to true.
# When true, each filename (without .ts) becomes a namespace under `en`.
# When false, everything goes into the "translation" namespace.
GROUP_BY_FILENAME_AS_NAMESPACE = false

# Matches JavaScript object keys: unquoted identifiers or quoted strings
PAIR_REGEX = /
  (?<key>
    [a-zA-Z_][a-zA-Z0-9_]*      # unquoted identifier (selectedTracks_one)
    |
    ['"][^'"]*['"]              # quoted key ('trackCheckbox.trackSelected')
  )
  \s*:\s*
  (?<val>
    "(?:[^"\\]|\\.)*"           # double-quoted string value
    |
    '(?:[^'\\]|\\.)*'           # single-quoted string value
  )
/x

# Collect all translations here
# Either: { "translation" => { "k" => "v" } }
# Or:     { "fileA" => { ... }, "fileB" => { ... } }
AGGREGATED = Hash.new { |h, k| h[k] = {} }

# Track key conflicts: { key => [{ file: "...", value: "..." }, ...] }
KEY_CONFLICTS = Hash.new { |h, k| h[k] = [] }

def import_file(file_path)
  puts "üìÇ Importing #{file_path}"
  content = File.read(file_path)

  namespace =
    if GROUP_BY_FILENAME_AS_NAMESPACE
      File.basename(file_path, ".ts")
    else
      "translation"
    end

  content.scan(PAIR_REGEX) do |key, raw_val|
    # Strip quotes from key if it's quoted
    key = key[1..-2] if key.start_with?('"', "'")
    
    # Strip quotes from value
    value = raw_val[1..-2] # strip surrounding quotes
    value = value.gsub("\\'", "'").gsub('\\"', '"')

    # Save into DB (kept from your original script)
    begin
      Localization::Original::Create.(:website_client_side, key, value, nil, false)
    rescue ActiveRecord::RecordNotUnique
      # Skip duplicates quietly
    rescue ActiveRecord::RecordInvalid => e
      puts "‚ö†Ô∏è Failed to import #{key}: #{e.message}"
    end

    # Check for key conflicts before aggregating
    if AGGREGATED[namespace][key] && AGGREGATED[namespace][key] != value
      # We have a conflict - same key, different values
      filename = File.basename(file_path)
      
      # Add current conflict
      KEY_CONFLICTS[key] << {
        file: filename,
        value: value,
        namespace: namespace
      }
      
      # Add previous value if this is the first conflict for this key
      if KEY_CONFLICTS[key].length == 1
        KEY_CONFLICTS[key].unshift({
          file: "previous", # We don't track which file had the original
          value: AGGREGATED[namespace][key],
          namespace: namespace
        })
      end
      
      puts "‚ö†Ô∏è  Key conflict detected: '#{key}'"
      puts "   Previous: #{AGGREGATED[namespace][key]}"
      puts "   Current:  #{value} (from #{filename})"
    end

    # Always store the latest value (last file wins)
    AGGREGATED[namespace][key] = value
  end
end

Dir.glob(DIR.join("*.ts")).each { |file| import_file(file) }

# Build the TypeScript module contents
# Shape matches i18next's `resources` option:
# { en: { translation: { ... } } } or { en: { ns1: {...}, ns2: {...} } }
resources_payload = { "en" => AGGREGATED }

# Serialize to JSON (safe escaping), then wrap as TypeScript
json = JSON.pretty_generate(resources_payload)
ts = <<~TS
  /* Auto-generated by script: #{File.basename(__FILE__)} */
  /* Do not edit by hand. */
  export const resources = #{json} as const;
  export default resources;
TS

File.write(OUTPUT_TS, ts)
puts "‚úÖ Wrote aggregated resources to: #{OUTPUT_TS}"

# Write conflicts file if any conflicts were found
if KEY_CONFLICTS.any?
  conflicts_json = JSON.pretty_generate(KEY_CONFLICTS)
  File.write(CONFLICTS_OUTPUT, conflicts_json)
  puts "‚ö†Ô∏è  #{KEY_CONFLICTS.size} key conflicts detected and saved to: #{CONFLICTS_OUTPUT}"
  puts "   Please review and resolve these conflicts manually."
else
  # Remove conflicts file if no conflicts
  File.delete(CONFLICTS_OUTPUT) if File.exist?(CONFLICTS_OUTPUT)
  puts "‚úÖ No key conflicts detected."
end